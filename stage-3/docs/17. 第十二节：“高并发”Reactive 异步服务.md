> <a name="d809g"></a>
#### 主要内容
> - 客户端 Reactive：基于 WebFlux 重构用户管理 REST 服务，比对 Servlet 异步 + 非阻塞的性能变化
> - 服务端 Reactive：基于 RSocket 实现服务端 Reactive 化，并利用背压（Back-Pressure） 重构订单处理，提升系统吞吐量

<a name="UvSLJ"></a>
# 理解 Reactive
<a name="FdCAD"></a>
## 关于 Reactive 的一些讲法

- Reactive 是异步非阻塞编程
- Reactive 能够提升程序性能
- Reactive 解决传统编程模型遇到的困境
<a name="GraVX"></a>
## Reactive 框架

- Java 9 Flow API
- RxJava
- Reactor
<a name="p8U1c"></a>
## 传统编程模型中的某些困境
<a name="IBJ52"></a>
## [Reactor](http://projectreactor.io/docs/core/release/reference/#_blocking_can_be_wasteful) 认为阻塞可能是浪费的
3.1. Blocking Can Be Wasteful<br />Modern applications can reach huge numbers of concurrent users, and, even though the capabilities of modern hardware have continued to improve, performance of modern software is still a key concern.<br />There are broadly two ways one can improve a program’s performance:

1. **parallelize**: use more threads and more hardware resources.
2. **seek more efficiency** in how current resources are used.

Usually, Java developers write programs using blocking code. This practice is fine until there is a performance bottleneck, at which point the time comes to introduce additional threads, running similar blocking code. But this scaling in resource utilization can quickly introduce contention and concurrency problems.<br />Worse still, blocking wastes resources.<br />So the parallelization approach is not a silver bullet.
<a name="Wr2JP"></a>
##### 观点归纳

- 阻塞导致性能瓶颈和浪费资源
- 增加线程可能会引起资源竞争和并发问题
- 并行的方式不是银弹（不能解决所有问题）
<a name="yafNK"></a>
### 理解阻塞的弊端
阻塞场景 - 数据顺序加载<br />加载流程如下图所示：
```
load() -> loadConfigurations() : 耗时 1s
loadConfigurations() -> loadUsers() :  耗时 2s
loadUsers() -> loadOrders() : 耗时 3s
```

- Java 实现
```java
public class DataLoader {

    public final void load() {
        long startTime = System.currentTimeMillis(); // 开始时间
        doLoad(); // 具体执行
        long costTime = System.currentTimeMillis() - startTime; // 消耗时间
        System.out.println("load() 总耗时：" + costTime + " 毫秒");
    }

    protected void doLoad() { // 串行计算
        loadConfigurations();    //  耗时 1s
        loadUsers();                  //  耗时 2s
        loadOrders();                // 耗时 3s
    } // 总耗时 1s + 2s  + 3s  = 6s

    protected final void loadConfigurations() {
        loadMock("loadConfigurations()", 1);
    }

    protected final void loadUsers() {
        loadMock("loadUsers()", 2);
    }

    protected final void loadOrders() {
        loadMock("loadOrders()", 3);
    }

    private void loadMock(String source, int seconds) {
        try {
            long startTime = System.currentTimeMillis();
            long milliseconds = TimeUnit.SECONDS.toMillis(seconds);
            Thread.sleep(milliseconds);
            long costTime = System.currentTimeMillis() - startTime;
            System.out.printf("[线程 : %s] %s 耗时 :  %d 毫秒\n",
                    Thread.currentThread().getName(), source, costTime);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        new DataLoader().load();
    }

}
```
<a name="IDpVY"></a>
#### 结论
由于加载过程串行执行的关系，导致消耗实现线性累加。Blocking 模式即串行执行 。
<a name="vB5pF"></a>
### 理解并行的复杂
<a name="qudR7"></a>
#### 并行场景 - 并行数据加载

- 图示
```
load() -> loadConfigurations() : 耗时 1s
load() -> loadUsers() :  耗时 2s
load() -> loadOrders() : 耗时 3s
```

- Java 代码
```java
public class ParallelDataLoader extends DataLoader {

    protected void doLoad() {  // 并行计算
        ExecutorService executorService = Executors.newFixedThreadPool(3); // 创建线程池
        CompletionService completionService = new ExecutorCompletionService(executorService);
        completionService.submit(super::loadConfigurations, null);      //  耗时 >= 1s
        completionService.submit(super::loadUsers, null);               //  耗时 >= 2s
        completionService.submit(super::loadOrders, null);              //  耗时 >= 3s

        int count = 0;
        while (count < 3) { // 等待三个任务完成
            if (completionService.poll() != null) {
                count++;
            }
        }
        executorService.shutdown();
    }  // 总耗时 max(1s, 2s, 3s)  >= 3s

    public static void main(String[] args) {
        new ParallelDataLoader().load();
    }

}
```
<a name="bF6Ds"></a>
#### 结论
明显地，程序改造为并行加载后，性能和资源利用率得到提升，消耗时间取最大者。
<a name="xZ72A"></a>
#### 延伸思考

1. 如果阻塞导致性能瓶颈和资源浪费的话，Reactive 也能解决这个问题？
2. 为什么不直接使用 Future#get() 方法强制所有任务执行完毕，然后再统计总耗时？
3. 由于以上三个方法之间没有数据依赖关系，所以执行方式由串行调整为并行后，能够达到性能提升的效果。如果方法之间存在依赖关系时，那么提升效果是否还会如此明显，并且如何确保它们的执行顺序？
<a name="iRT1F"></a>
### [Reactor](http://projectreactor.io/docs/core/release/reference/#_asynchronicity_to_the_rescue) 认为异步不一定能够救赎
<a name="mRWoY"></a>
#### 3.2. Asynchronicity to the Rescue?
The second approach (mentioned earlier), seeking more efficiency, can be a solution to the resource wasting problem. By writing _asynchronous_, _non-blocking_ code, you let the execution switch to another active task **using the same underlying resources** and later come back to the current process when the asynchronous processing has finished.<br />Java offers two models of asynchronous programming:

- **Callbacks**: Asynchronous methods do not have a return value but take an extra callback parameter (a lambda or anonymous class) that gets called when the result is available. A well known example is Swing’s EventListener hierarchy.
- **Futures**: Asynchronous methods return a Future<T> **immediately**. The asynchronous process computes a T value, but the Future object wraps access to it. The value is not immediately available, and the object can be polled until the value is available. For instance, ExecutorService running Callable<T> tasks use Future objects.

Are these techniques good enough? Not for every use case, and both approaches have limitations.<br />Callbacks are hard to compose together, quickly leading to code that is difficult to read and maintain (known as "Callback Hell").<br />Futures are a bit better than callbacks, but they still do not do well at composition, despite the improvements brought in Java 8 by CompletableFuture.
<a name="cEu6t"></a>
#### 观点归纳

- Callbacks 是解决非阻塞的方案，然而他们之间很难组合，并且快速地将代码引导至 "Callback Hell" 的不归路
- Futures 相对于 Callbacks 好一点，不过还是无法组合，不过  CompletableFuture 能够提升这方面的不足
<a name="wKXsC"></a>
#### 理解 "Callback Hell"

- Java GUI 示例
```java
public class JavaGUI {

    public static void main(String[] args) {
        JFrame jFrame = new JFrame("GUI 示例");
        jFrame.setBounds(500, 300, 400, 300);
        LayoutManager layoutManager = new BorderLayout(400, 300);
        jFrame.setLayout(layoutManager);
        jFrame.addMouseListener(new MouseAdapter() { // callback 1
            @Override
            public void mouseClicked(MouseEvent e) {
                System.out.printf("[线程 : %s] 鼠标点击，坐标(X : %d, Y : %d)\n",
                        currentThreadName(), e.getX(), e.getY());
            }
        });
        jFrame.addWindowListener(new WindowAdapter() {  // callback 2
            @Override
            public void windowClosing(WindowEvent e) {
                System.out.printf("[线程 : %s] 清除 jFrame... \n", currentThreadName());
                jFrame.dispose(); // 清除 jFrame
            }

            @Override
            public void windowClosed(WindowEvent e) {
                System.out.printf("[线程 : %s] 退出程序... \n", currentThreadName());
                System.exit(0); // 退出程序
            }
        });
        System.out.println("当前线程：" + currentThreadName());
        jFrame.setVisible(true);
    }

    private static String currentThreadName() { // 当前线程名称
        return Thread.currentThread().getName();
    }
}
```
<a name="IYPyx"></a>
##### 结论
Java GUI 以及事件/监听模式基本采用匿名内置类实现，即回调实现。从本例可以得出，鼠标的点击确实没有被其他线程给阻塞。不过当监听的维度增多时，Callback 实现也随之增多。同时，事件/监听者模式的并发模型可为同步或异步。
<a name="KuXy2"></a>
##### 回顾

- Spring 事件/监听器（同步/异步）：
   - 事件： ApplicationEvent
   - 事件监听器：ApplicationListener
   - 事件广播器：ApplicationEventMulticaster
   - 事件发布器：ApplicationEventPublisher
- Servlet 事件/监听器
   - 同步
      - 事件：ServletContextEvent
      - 事件监听器：ServletContextListener
   - 异步
      - 事件：AsyncEvent
      - 事件监听器：AsyncListener
<a name="aVoIP"></a>
#### 理解 Future 阻塞问题
如果 DataLoader 的 loadOrders() 方法依赖于 loadUsers() 的结果，而 loadUsers() 又依赖于 loadConfigurations() ，调整实现：
```java
public class FutureBlockingDataLoader extends DataLoader {

    protected void doLoad() {
        ExecutorService executorService = Executors.newFixedThreadPool(3); // 创建线程池
        runCompletely(executorService.submit(super::loadConfigurations));
        runCompletely(executorService.submit(super::loadUsers));
        runCompletely(executorService.submit(super::loadOrders));
        executorService.shutdown();
    }

    private void runCompletely(Future<?> future) {
        try {
            future.get();
        } catch (Exception e) {
        }
    }

    public static void main(String[] args) {
        new FutureBlockingDataLoader().load();
    }

}
```
<a name="hQhay"></a>
##### 结论
Future#get() 方法不得不等待任务执行完成，换言之，如果多个任务提交后，返回的多个 Future 逐一调用 get() 方法时，将会依次 blocking，任务的执行从并行变为串行。这也是之前 ”“延伸思考” 问答 2 的答案：<br />2.为什么不直接使用 Future#get() 方法强制所有任务执行完毕，然后再统计总耗时？
<a name="faOC7"></a>
#### 理解 Future 链式问题
由于 Future 无法实现异步执行结果链式处理，尽管 FutureBlockingDataLoader 能够解决方法数据依赖以及顺序执行的问题，不过它将并行执行带回了阻塞（串行）执行。所以，它不是一个理想实现。不过 CompletableFuture 可以帮助提升 Future 的限制：
```java
public class ChainDataLoader extends DataLoader {

    protected void doLoad() {
        CompletableFuture
                .runAsync(super::loadConfigurations)
                .thenRun(super::loadUsers)
                .thenRun(super::loadOrders)
                .whenComplete((result, throwable) -> { // 完成时回调
                    System.out.println("加载完成");
                })
                .join(); // 等待完成
    }

    public static void main(String[] args) {
        new ChainDataLoader().load();
    }
}
```

- 图解
```
main 线程 -> CompletableFuture 线程 : 线程切换
CompletableFuture 线程 -> loadConfigurations() : 1s
loadConfigurations() -> loadUsers() : 2s
loadUsers() -> loadOrders() : 3s
loadOrders() -> whenComplete(BiConsumer) : 执行完成时回调 
CompletableFuture 线程 -> main 线程:  等待 CompletableFuture 线程执行结束
```
<a name="gCstf"></a>
### 结论

1. 如果阻塞导致性能瓶颈和资源浪费的话，Reactive 也能解决这个问题？
2. CompletableFuture 属于异步操作，如果强制等待结束的话，又回到了阻塞编程的方式，那么 Reactive 也会面临同样的问题吗？
3. CompletableFuture 让我们理解到非阻塞不一定提升性能，那么 Reactive 也会这样吗？
<a name="YDcAE"></a>
### [Reactive Streams JVM](https://github.com/reactive-streams/reactive-streams-jvm#goals-design-and-scope) 认为异步系统和资源消费需要特殊处理
Handling streams of data—especially “live” data whose volume is not predetermined—requires special care in an asynchronous system. The most prominent issue is that resource consumption needs to be carefully controlled such that a fast data source does not overwhelm the stream destination. Asynchrony is needed in order to enable the parallel use of computing resources, on collaborating network hosts or multiple CPU cores within a single machine.<br />观点归纳：

- 流式数据容量难以预判
- 异步编程复杂
- 数据源和消费端之间资源消费难以平衡
<a name="iIqzc"></a>
#### Reactive 是要解决以上所有问题吗？
<a name="PX3OB"></a>
#### 思考

- Reactive 到底是什么？
- Reactive 的使用场景在哪里？
- Reactive 存在怎样限制/不足？
<a name="wswvk"></a>
### Reactive Programming 定义
<a name="AaDNI"></a>
#### [The Reactive Manifesto](https://www.reactivemanifesto.org/)
Reactive Systems are: Responsive, Resilient, Elastic and Message Driven.<br />[https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)<br />关键字：

- 响应的（Responsive）
- 适应性强的（Resilient）
- 弹性的（Elastic）
- 消息驱动的（Message Driven）

侧重点：

- 面向 Reactive 系统
- Reactive 系统原则
<a name="iSZxB"></a>
#### [维基百科](https://en.wikipedia.org/wiki/Reactive_programming)
Reactive programming is a declarative programming paradigm concerned with **data streams** and the **propagation of change**. With this paradigm it is possible to express static (e.g. arrays) or dynamic (e.g. event emitters) data streams with ease, and also communicate that an inferred dependency within the associated execution model exists, which facilitates the automatic propagation of the changed data flow.<br />[https://en.wikipedia.org/wiki/Reactive_programming](https://en.wikipedia.org/wiki/Reactive_programming)<br />关键字：

- 数据流（data streams ）
- 传播变化（ propagation of change）

侧重点：

- 数据结构
   - 数组（arrays）
   - 事件发射器（event emitters）
- 数据变化

技术连接：

- 数据流：Java 8 Stream
- 传播变化：Java Observable/Observer
- 事件：Java EventObject/EventListener
<a name="vooSu"></a>
#### [Spring Framework](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-why-reactive)
The term "reactive" refers to programming models that are built around **reacting to change** — network component reacting to I/O events, UI controller reacting to mouse events, etc. In that sense **non-blocking** is reactive because instead of being blocked we are now in the mode of reacting to notifications as operations complete or data becomes available.<br />[https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-why-reactive](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-why-reactive)<br />关键字：

- 变化响应（reacting to change ）
- 非阻塞（non-blocking）

侧重点：

- 响应通知
   - 操作完成（operations complete）
   - 数据可用（data becomes available）

技术连接：

- 非阻塞：Servlet 3.1ReadListener/WriteListener
- 响应通知：Servlet 3.0 AsyncListener
<a name="Adlrx"></a>
#### [ReactiveX](http://reactivex.io/intro.html)
ReactiveX extends the observer pattern to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.<br />[http://reactivex.io/intro.html](http://reactivex.io/intro.html)<br />关键字：

- 观察者模式（Observer pattern ）
- 数据/事件序列（Sequences of data and/or events )
- 序列操作符（Opeators）
- 屏蔽并发细节（abstracting away…）

侧重点：

- 设计模式
- 数据结构
- 数据操作
- 并发模型

技术连接：

- 观察者模式：Java Observable/Observer
- 数据/事件序列：Java 8 Stream
- 数据操作：Java 8 Stream
- 屏蔽并发细节（abstracting away…）：Exectuor 、Future、Runnable
<a name="otix5"></a>
#### [Reactor](http://projectreactor.io/docs/core/release/reference/#intro-reactive)
The reactive programming paradigm is often presented in object-oriented languages as an extension of the Observer design pattern. One can also compare the main reactive streams pattern with the familiar Iterator design pattern, as there is a duality to the Iterable-Iterator pair in all of these libraries. One major difference is that, while an Iterator is pull-based, reactive streams are push-based.<br />[http](http://projectreactor.io/docs/core/release/reference/)[://projectreactor.io/docs/core/release/reference/#](http://projectreactor.io/docs/core/release/reference/)[intro-reactive](http://projectreactor.io/docs/core/release/reference/)<br />关键字：

- 观察者模式（Observer pattern ）
- 响应流模式（Reactive streams pattern ）
- 迭代器模式（Iterator pattern）
- 拉模式（pull-based）
- 推模式（push-based）

侧重点：

- 设计模式
- 数据获取方式

技术连接：

- 观察者模式：Java Observable/Observer
- 响应流模式：Java 8 Stream
- 迭代器模式：Java Iterator
<a name="jotx7"></a>
#### [@andrestaltz](https://twitter.com/andrestaltz)
[Reactive programming is programming withasynchronous data streams.](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#reactive-programming-is-programming-with-asynchronous-data-streams)<br />In a way, **this isn't anything new**. Event buses or your typical click events are really an asynchronous event stream, on which you can observe and do some side effects. Reactive is that **idea on steroids**. You are able to create data streams of anything, not just from click and hover events. Streams are cheap and ubiquitous, anything can be a stream: variables, user inputs, properties, caches, data structures, etc.<br />["What is Reactive Programming?"](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#what-is-reactive-programming)<br />关键字：

- 异步（asynchronous ）
- 数据流（data streams）
- 并非新鲜事物（not anything new）
- 过于理想化（idea on steroids）

侧重点：

- 并发模型
- 数据结构
- 技术本质

技术连接：

- 异步：Java Future
- 数据流：Java 8 Stream
<a name="LZCq8"></a>
### Reactive Programming 特性
<a name="gCf0X"></a>
##### 编程模型（Programming Models）

- 响应式编程
- 函数式编程

参考资源：[WebFlux 编程模型](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-programming-models)
<a name="i5ujq"></a>
###### 对立模型 - [Imperative programming](https://en.wikipedia.org/wiki/Imperative_programming)
Imperative programming is a programming paradigm that uses statements that change a program's state. In much the same way that the imperative mood in natural languages expresses commands, an imperative program consists of commands for the computer to perform. Imperative programming focuses on describing how a program operates.<br />[https://en.wikipedia.org/wiki/Imperative_programming](https://en.wikipedia.org/wiki/Imperative_programming)
<a name="nYVwx"></a>
###### 小结
Reactive Programming：同步或异步非阻塞执行，数据传播被动通知<br />Imperative programming：同步阻塞执行，数据主动获取
<a name="YKw1c"></a>
##### 设计模式（Design Patterns）

- 扩展模式：观察者（[Observer](https://en.wikipedia.org/wiki/Observer_pattern)）
   - 推模式（push-based）
- 混合模式：反应堆（[Reactor](https://en.wikipedia.org/wiki/Reactor_pattern)）、[Proactor](https://en.wikipedia.org/wiki/Proactor_pattern)
- 对立模式：迭代器（[Iterator](https://en.wikipedia.org/wiki/Iterator_pattern)）
   - 拉模式（pull-based）
<a name="UseoD"></a>
###### 模式对比
An Observable(RxJava) is the asynchronous/push [“dual”](http://en.wikipedia.org/wiki/Dual_(category_theory)) to the synchronous/pull Iterable

| event | Iterable (pull) | Observable (push) |
| --- | --- | --- |
| data | T next() | onNext(T) |
| discover error | throws Exception | onError(Exception) |
| complete | !hasNext() | onCompleted() |

<a name="iW7yd"></a>
###### 小结
Reactive Programming 作为观察者模式（[Observer](https://en.wikipedia.org/wiki/Observer_pattern)） 的延伸，在处理流式数据的过程中，并非使用传统的命令编程方式（ [Imperative programming](https://en.wikipedia.org/wiki/Imperative_programming)）同步拉取数据，如迭代器模式（[Iterator](https://en.wikipedia.org/wiki/Iterator_pattern)） ，而是采用同步或异步非阻塞地推拉相结合的方式，响应数据传播时的变化。
<a name="cjUgy"></a>
##### 数据结构（Data Structure）

- 流式（Streams）
- 序列（Sequences ）
- 事件（Events）
<a name="bi2dC"></a>
###### 小结
A stream is a sequence of **ongoing events ordered in time**.<br />["What is Reactive Programming?"](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#what-is-reactive-programming)
<a name="U3pdM"></a>
##### 并发模式（Concurrency Model）

- 非阻塞（Non-Blocking）
   - 同步（Synchronous ）
   - 异步（Asynchronous ）
<a name="vI01g"></a>
###### 小结
屏蔽并发编程细节，如线程、同步、线程安全以及并发数据结构。
<a name="am5VR"></a>
### Reactive Programming 使用场景
<a name="SyrDF"></a>
#### [Reactive Streams JVM](https://github.com/reactive-streams/reactive-streams-jvm)
The main goal of Reactive Streams is to govern the exchange of stream data across an asynchronous boundary.<br />[https://github.com/reactive-streams/reactive-streams-jvm](https://github.com/reactive-streams/reactive-streams-jvm)<br />主要目的：

- 管理流式数据交换（ govern the exchange of stream data）
- 异步边界（asynchronous boundary）
<a name="T1XCc"></a>
#### [Spring Framework](https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/web-reactive.html#webflux-performance)
Reactive and non-blocking generally do not make applications run faster. They can, in some cases, for example if using the WebClient to execute remote calls in parallel. On the whole it requires more work to do things the non-blocking way and that can increase slightly the required processing time.<br />The key expected benefit of reactive and non-blocking is the ability to scale with a small, fixed number of threads and less memory. That makes applications more resilient under load because they scale in a more predictable way.<br />主要目的：

- 通常并非让应用运行更快速（generally do not make applications run faster）
- 利用较少的资源提升伸缩性（scale with a small, fixed number of threads and less memory）
<a name="DTnCH"></a>
#### [ReactiveX](http://reactivex.io/intro.html)
The ReactiveX Observable model allows you to treat streams of asynchronous events with the same sort of simple, composable operations that you use for collections of data items like arrays. It frees you from tangled webs of callbacks, and thereby makes your code more readable and less prone to bugs.<br />主要目的：

- 更好可读性（more readable）
- 减少 bugs（less prone to bugs）

核心技术：

- 异步（asynchronous）
- 同顺序（same sort）
- 组合操作（composable operations）

**Java 原生技术限制**：

- Stream 存在组合限制
<a name="F39bt"></a>
#### [Reactor](http://projectreactor.io/docs/core/release/reference/#intro-reactive)
Composability and readability<br />Data as a flow manipulated with a rich vocabulary of operators<br />Nothing happens until you subscribe<br />Backpressure or the ability for the consumer to signal the producer that the rate of emission is too high<br />High level but high value abstraction that is concurrency-agnostic<br />主要目的：

- 结构性和可读性（Composability and readability）
- 高层次并发抽象（High level abstraction）

核心技术：

- 丰富的数据操作符（ rich vocabulary of operators）
- 背压（Backpressure）
- 订阅式数据消费（Nothing happens until you subscribe）

**Java 原生技术限制**：

- Stream 有限操作符
- Stream 不支持背压
- Stream 不支持订阅
<a name="Xj1jS"></a>
### 总结 Reactive Programming
Reactive Programming 作为观察者模式（[Observer](https://en.wikipedia.org/wiki/Observer_pattern)） 的延伸，不同于传统的命令编程方式（ [Imperative programming](https://en.wikipedia.org/wiki/Imperative_programming)）同步拉取数据的方式，如迭代器模式（[Iterator](https://en.wikipedia.org/wiki/Iterator_pattern)） 。而是采用数据发布者同步或异步地推送到数据流（Data Streams）的方案。当该数据流（Data Steams）订阅者监听到传播变化时，立即作出响应动作。在实现层面上，Reactive Programming 可结合函数式编程简化面向对象语言语法的臃肿性，屏蔽并发实现的复杂细节，提供数据流的有序操作，从而达到提升代码的可读性，以及减少 Bugs 出现的目的。同时，Reactive Programming 结合背压（Backpressure）的技术解决发布端生成数据的速率高于订阅端消费的问题。
<a name="H3v8x"></a>
## Reactive Streams 规范
Reactive Streams is a standard and specification for Stream-oriented libraries for the JVM that

- process a potentially unbounded number of elements
- in sequence,
- asynchronously passing elements between components,
- with mandatory non-blocking backpressure.
<a name="hUI0Y"></a>
### API 组件
<a name="LT6E6"></a>
#### Publisher
数据发布者，数据上游
<a name="uM2nJ"></a>
##### 接口
```java
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```
<a name="AvWrr"></a>
#### Subscriber
数据订阅者，数据上游
<a name="UPRZ8"></a>
##### 接口
```java
public interface Subscriber<T> {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```
<a name="dC3eN"></a>
##### 信号事件

- onSubscribe：当下游订阅时
- onNext：当下游接收数据时
- onComplete：当数据流（Data Streams）执行完成时
- onError： 当数据流（Data Streams）执行错误时
<a name="U59fb"></a>
#### Subscription
订阅信号控制
<a name="QMa1d"></a>
##### 接口
```java
public interface Subscription {
    public void request(long n);
    public void cancel();
}
```
<a name="g7FO6"></a>
##### 信号操作

- request：请求上游元素的数量
- cancel：请求停止发送数据并且清除资源
<a name="U7bOs"></a>
#### Processor
消息发布者和订阅者综合体
<a name="OKepj"></a>
##### 接口
```java
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```
<a name="Wte8p"></a>
### 背压（Backpressure）
<a name="FF6JN"></a>
#### [维基百科](https://en.wikipedia.org/wiki/Back_pressure)
The term is also used analogously in the field of information technology to describe the build-up of data behind an I/O switch if the buffers are full and incapable of receiving any more data; the transmitting device halts the sending of data packets until the buffers have been emptied and are once more capable of storing information. It also refers to an algorithm for routing data according to congestion gradients (see backpressure routing).<br />关键字：

- I/O 切换（I/O switch ）
- 缓冲填满（the buffers are full ）
- 数据无法接受（incapable of receiving any more data）
- 传输设备（transmitting device ）
- 停止发送数据包 （halts the sending of data packets ）
<a name="stVBn"></a>
#### [Reactive Streams JVM](https://github.com/reactive-streams/reactive-streams-jvm#subscriber-controlled-queue-bounds)
Backpressure is an integral part of this model in order to allow the queues which mediate between threads to be bounded.<br />Since back-pressure is mandatory the use of unbounded buffers can be avoided. In general, the only time when a queue might grow without bounds is when the publisher side maintains a higher rate than the subscriber for an extended period of time, but this scenario is handled by backpressure instead.<br />[https](https://github.com/reactive-streams/reactive-streams-jvm)[://](https://github.com/reactive-streams/reactive-streams-jvm)[github.com/reactive-streams/reactive-streams-jvm](https://github.com/reactive-streams/reactive-streams-jvm)<br />关键字：

- 线程和边界间调停（mediate between threads to be bounded）
- 发布者维持速率高于订阅者（publisher side maintains a higher rate than the subscriber）
- 背压处理（handled by backpressure）
<a name="EZPeD"></a>
#### [Reactor](http://projectreactor.io/docs/core/release/reference/#reactive.backpressure)
Propagating signals upstream is also used to implement **backpressure**, which we described in the assembly line analogy as a feedback signal sent up the line when a workstation processes more slowly than an upstream workstation.<br />The real mechanism defined by the Reactive Streams specification is pretty close to the analogy: a subscriber can work in _unbounded_ mode and let the source push all the data at its fastest achievable rate or it can use the request mechanism to signal the source that it is ready to process at most n elements.<br />关键字：

- Propagating signals upstream（传播上游信号）
- 无边界模式（_unbounded_ mode）
- 处理最大元素数量（process at most n elements）
<a name="N0uur"></a>
#### 总结背压
假设下游Subscriber工作在无边界大小的数据流水线时，当上游Publisher提供数据的速率快于下游Subscriber的消费数据速率时，下游Subscriber将通过传播信号（request）到上游Publisher，请求限制数据的数量（ Demand ）或通知上游停止数据生产。
<a name="cxrcM"></a>
## Reactor 框架运用
<a name="V0mdJ"></a>
### 核心 API
<a name="StGRs"></a>
#### Mono
定义：0-1 的非阻塞结果<br />实现：Reactive Streams JVM API Publisher<br />类比：非阻塞 Optional
<a name="AgE44"></a>
##### 类似模式
点对点模式<br />![q004870a.gif](https://cdn.nlark.com/yuque/0/2023/gif/222258/1692014708508-5cafcf0f-e3c1-42f5-9907-1aa409b6342b.gif#averageHue=%23f1f1f0&clientId=u27630e6e-227a-4&from=drop&id=u89da553e&originHeight=87&originWidth=365&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=6307&status=done&style=none&taskId=ud9a9605a-7d38-4b18-bbec-0fe7bb640f2&title=)
<a name="bsQAS"></a>
##### 图解
![mono.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1692014676382-db6851b9-2374-4dfd-8cf9-75b968f63646.png#averageHue=%23090808&clientId=u27630e6e-227a-4&from=drop&id=ud95eb797&originHeight=227&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=58377&status=done&style=none&taskId=uc1d97891-beb8-4167-a2ee-9c36934042e&title=)
<a name="XPPej"></a>
#### Flux
定义：0-N 的非阻塞序列<br />实现：Reactive Streams JVM API Publisher<br />类比：非阻塞 Stream
<a name="PHCUE"></a>
##### 类似模式
发布者/订阅者模式
<a name="uSuJc"></a>
##### 图解
![flux.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1692014703847-11ef6617-04e6-46b7-b660-0da2b4f6b5a1.png#averageHue=%230b0a09&clientId=u27630e6e-227a-4&from=drop&id=u4b6624d5&originHeight=227&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=75677&status=done&style=none&taskId=u90740942-4396-4200-8ddc-6dbab5f4ec6&title=)
<a name="o5dDE"></a>
#### Scheduler
定义：Reactor 调度线程池

- 当前线程：Schedulers.immediate()
   - 等价关系：Thread.currentThread()
- 单复用线程：Schedulers.single()
   - 内部名称："single"
   - 线程名称："single"
   - 线程数量：单个
   - 线程idel时间：Long Live
   - 底层实现：ScheduledThreadPoolExecutor (core 1)
- 弹性线程池：Schedulers.elastic()
   - 内部名称："elastic"
   - 线程名称："elastic-evictor-{num}"
   - 线程数量：无限制（unbounded）
   - 线程idel时间：60 秒
   - 底层实现：ScheduledThreadPoolExecutor
- 并行线程池：Schedulers.parallel()
   - 内部名称："parallel"
   - 线程名称："parallel-{num}"
   - 线程数量：处理器数量
   - 线程idel时间：60 秒
   - 底层实现：ScheduledThreadPoolExecutor
<a name="fF232"></a>
### 实战
<a name="coB5n"></a>
#### Maven 依赖
```xml
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-core</artifactId>
</dependency>
```
<a name="CWmxU"></a>
#### 同步处理
<a name="zvwku"></a>
##### generate 方法
generate 方法生成同步并且一对一提交 Flux，sink 实现 SynchronousSink
```java
Flux<String> flux = Flux.generate(
                () -> 0, // 数据源
                (value, sink) -> { // value 为当前执行的值，sink 是 单信号 Subscriber 的抽象
                    sink.next("value : " + value);
                    if (value == 10) sink.complete();
                    return value + 1;
                });
flux.subscribe(Utils::println);
```
<a name="J2DOV"></a>
##### create 方法
create 方法生成
<a name="Agdut"></a>
##### handle 方法
```java
Flux.range(0, 10).handle((item, sink) -> {
  if (item % 2 == 0) {
    sink.next("Even : " + item);
  }
}).subscribe(Utils::println);
```
<a name="KNASp"></a>
# WebFlux 核心
<a name="OdpjF"></a>
## 基本介绍
Spring WebFlux 是一套全新的 Reactive Web 栈技术，实现完全非阻塞，支持 Reactive Streams 背压等特性，并且运行环境不限于 Servlet 容器（Tomcat、Jetty、Undertow），如 Netty 等。<br />The original web framework included in the Spring Framework, Spring Web MVC, was purpose built for the Servlet API and Servlet containers. The reactive stack, web framework, Spring WebFlux, was added later in version 5.0. It is fully non-blocking, supports [Reactive Streams](http://www.reactive-streams.org/) back pressure, and runs on servers such as Netty, Undertow, and Servlet 3.1+ containers.<br />Spring WebFlux 与 Spring MVC 可共存，在 Spring Boot 中，Spring MVC 优先级更高。<br />Both web frameworks mirror the names of their source modules [spring-webmvc](https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc) and [spring-webflux](https://github.com/spring-projects/spring-framework/tree/master/spring-webflux) and co-exist side by side in the Spring Framework. Each module is optional. Applications may use one or the other module, or in some cases both — e.g. Spring MVC controllers with the reactive WebClient.
<a name="ABTFy"></a>
### 动机
<a name="mZTA5"></a>
#### [Spring 官方说法](https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-new-framework)
Part of the answer is the need for a non-blocking web stack to handle concurrency with a small number of threads and scale with less hardware resources. Servlet 3.1 did provide an API for non-blocking I/O. However, using it leads away from the rest of the Servlet API where contracts are synchronous (Filter, Servlet) or blocking (getParameter, getPart). This was the motivation for a new common API to serve as a foundation across any non-blocking runtime. That is important because of servers such as Netty that are well established in the async, non-blocking space.<br />The other part of the answer is functional programming. Much like the addition of annotations in Java 5 created opportunities — e.g. annotated REST controllers or unit tests, the addition of lambda expressions in Java 8 created opportunities for functional APIs in Java. This is a boon for non-blocking applications and continuation style APIs — as popularized by CompletableFuture and [ReactiveX](http://reactivex.io/), that allow declarative composition of asynchronous logic. At the programming model level Java 8 enabled Spring WebFlux to offer functional web endpoints alongside with annotated controllers.<br />原文链接：[https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-new-framework](https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-new-framework)
<a name="ZCoXB"></a>
#### 实际动机
从 Spring MVC 注解驱动的时代开始，Spring 官方有意识地**去 Servlet 化**。不过在 Spring MVC 的时代，Spring 扔摆脱不了 Servlet 容器的依赖，然而 Spring 借助 Reactive Programming 的势头，WebFlux 将 Servlet 容器从必须项变为可选项，并且默认采用 Netty Web Server 作为基础，从而逐渐地形成 Spring 全新技术体系，包括数据存储等技术栈：
<a name="omahL"></a>
### ![](https://cdn.nlark.com/yuque/0/2023/svg/222258/1692025368835-25c0f07d-b7bc-4ef7-aa1e-c170a17b192f.svg#clientId=u27630e6e-227a-4&from=paste&height=1506&id=uf65de955&originHeight=150&originWidth=198&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ua390d313-49ce-422b-8ac0-25750f9757d&title=&width=1988)
<a name="RaimW"></a>
## 编程模型
<a name="ShYLL"></a>
### 注解驱动 （[Annotated Controllers](https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-controller)）
<a name="zMTu6"></a>
#### 定义
| 特性 | Spring Web MVC | Spring WebFlux |
| --- | --- | --- |
| 应用控制器注解声明 | @Controller | 相同 |
| 应用 REST 控制器注解声明 | @RestController | 相同 |

<a name="lm8ZM"></a>
#### 映射
| 特性 | Spring Web MVC | Spring WebFlux |
| --- | --- | --- |
| 请求映射注解声明 | @RequestMapping | 相同 |
| GET 方法映射 | @GetMapping | 相同 |
| POST 方法映射 | @PostMapping | 相同 |
| PUT 方法映射 | @PutMapping | 相同 |
| DELETE 方法映射 | @DeleteMapping | 相同 |
| PATCH 方法映射 | @PatchMapping | 相同 |

<a name="uT6OE"></a>
#### 请求
| 特性 | Spring Web MVC | Spring WebFlux |
| --- | --- | --- |
| 获取请求参数 | @RequestParam | 相同 |
| 获取请求头 | @RequestHeader | 相同 |
| 获取Cookie值 | @CookieValue | 相同 |
| 获取完整请求主体内容 | @RequestBody | 相同 |
| 获取请求路径变量 | @PathVariable | 相同 |
| 获取请求内容（包括请求主体和请求头） | RequestEntity | 相同 |

<a name="oxRkw"></a>
#### 响应
| 特性 | Spring Web MVC | Spring WebFlux |
| --- | --- | --- |
| 响应主体注解声明 | @ResponseBody | 相同 |
| 响应内容（包括响应主体和响应头） | ResponseEntity | 相同 |
| ResponseCookie | 响应 Cookie 内容 | 相同 |

<a name="TigVn"></a>
#### 拦截
| 特性 | Spring Web MVC | Spring WebFlux |
| --- | --- | --- |
| @Controller 注解切面通知 | @ControllerAdvice | 相同 |
| @RestController 注解切面通知 | @RestControllerAdvice | 相同 |

<a name="a8jHc"></a>
#### 跨域
| 特性 | Spring Web MVC | Spring WebFlux |
| --- | --- | --- |
| 资源跨域声明注解 | @CrossOrigin | 相同 |
| 资源跨域拦截器 | CorsFilter | CorsWebFilter |
| 注册资源跨域信息 | WebMvcConfigurer#addCorsMappings | WebFluxConfigurer#addCorsMappings |

<a name="NSR7q"></a>
### 函数式端点（[Functional Endpoints](https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-fn)）
<a name="XTo0n"></a>
#### Java 函数编程基础
<a name="Y7aCd"></a>
##### 函数式接口 - @FunctionInterface
用于函数式接口类型声明的信息注解类型，这些接口的实例被 Lambda 表示式、方法引用或构造器引用创建。函数式接口只能有一个抽象方法，并排除接口默认方法以及声明中覆盖 Object 的公开方法的统计。同时，@FunctionalInterface 不能标注在注解、类以及枚举上。如果违背以上规则，那么接口不能视为函数式接口，当标注 @FunctionalInterface 后，会引起编译错误。<br />不过，如果任一接口满足以上函数式接口的要求，无论接口声明中是否标注 @FunctionalInterface，均能被编译器视作函数式接口。
<a name="h62LC"></a>
##### 消费函数 - Consumer
只有输入，没有输出
<a name="wLqRo"></a>
##### 生产函数 -Supplier
没有输入，只有输出
<a name="TWu2h"></a>
##### 处理函数 - Function
有输出，有输出
<a name="VFECg"></a>
##### 判定函数 - Predicate
判定输入真伪性
<a name="vBpiV"></a>
#### 映射路由接口 - RouterFunction
<a name="Ms8VA"></a>
##### 函数映射
```java
RouterFunction<ServerResponse> route =
    route(GET("/person/{id}").and(accept(APPLICATION_JSON)), handler::getPerson)
        .andRoute(GET("/person").and(accept(APPLICATION_JSON)), handler::listPeople)
        .andRoute(POST("/person"), handler::createPerson);
```
<a name="GH5AM"></a>
##### 注解映射
```java
@GetMapping(value="/person/{id}",consumes=APPLICATION_JSON)
public void getPerson(HttpServletRequest request，HttpServletResponse) {
    
}

@GetMapping(value="/person",consumes=APPLICATION_JSON)
public void listPeople(HttpServletRequest request，HttpServletResponse) {
    
}

@PostMapping(value="/person")
public void createPerson(HttpServletRequest request，HttpServletResponse) {
    
}
```
<a name="FfjeO"></a>
##### 函数处理接口
Function 接口
```java
public class PersonHandler {

    // ...

    public Mono<ServerResponse> listPeople(ServerRequest request) {
        // ...
    }

    public Mono<ServerResponse> createPerson(ServerRequest request) {
        // ...
    }

    public Mono<ServerResponse> getPerson(ServerRequest request) {
        // ...
    }
}
```
<a name="IoErf"></a>
##### 路由方法 - RouteFunctions#route
<a name="erUhv"></a>
##### 请求判定 - RequestPredicate
类似于 Predicate，判断 ServerRequest
<a name="DYXdh"></a>
##### 处理器函数 - HandlerFunction
<a name="XrcTO"></a>
#### HTTP 请求接口 - ServerRequest
<a name="agzh8"></a>
#### HTTP 响应接口- ServerResponse
<a name="pex8u"></a>
## 并发模型
<a name="cRBxG"></a>
### Spring 官方说明
Spring MVC 和 Spring WebFlux 均能使用注解驱动 Controller，然而不同点在于并发模型和阻塞特性。<br />Both Spring MVC and Spring WebFlux support annotated controllers, but there is a key difference in the concurrency model and default assumptions for blocking and threads.<br />Spring MVC 通常是 Servlet 应用，因此，可能被当前线程阻塞。以远程调用为例，由于阻塞的缘故，导致 Servlet 容器使用较大的线程池处理请求。<br />In Spring MVC, and servlet applications in general, it is assumed that applications _may block_ the current thread, e.g. for remote calls, and for this reason servlet containers use a large thread pool, to absorb potential blocking during request handling.<br />Spring WebFlux 通常是非阻塞服务，不会发生阻塞，因此该阻塞服务器可使用少量、固定大小的线程池处理请求。<br />In Spring WebFlux, and non-blocking servers in general, it is assumed that applications _will not block_, and therefore non-blocking servers use a small, fixed-size thread pool (event loop workers) to handle requests.
<a name="yEli3"></a>
## 核心组件
<a name="bOQ3G"></a>
### HttpHandler API
<a name="Y4dDs"></a>
#### 基本概念
HttpHandler 是一种带有处理 HTTP 请求和响应方法的简单契约。<br />HttpHandleris a simple contract with a single method to handle a request and response.<br />Lowest level contract for reactive HTTP request handling that serves as a common denominator across different runtimes.
<a name="aJZXM"></a>
#### 接口定义
```java
public interface HttpHandler {

   /**
    * Handle the given request and write to the response.
    * @param request current request
    * @param response current response
    * @return indicates completion of request handling
    */
   Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response);

}
```
<a name="PQgMJ"></a>
### WebHandler API
<a name="ySJ2P"></a>
#### [Bean 类型](https://docs.spring.io/spring/docs/5.0.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api-special-beans)
| Bean 名称 | Bean 类型 | 数量 | 描述 |
| --- | --- | --- | --- |
|  | WebExceptionHandler | 0..N | Provide handling for exceptions from the chain of WebFilter's and the target WebHandler. For more details, see [Exceptions](https://docs.spring.io/spring/docs/5.0.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-exception-handler)<br />. |
|  | WebFilter | 0..N | Apply interception style logic to before and after the rest of the filter chain and the target WebHandler. For more details, see [Filters](https://docs.spring.io/spring/docs/5.0.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-filters)<br />. |
| "webHandler" | WebHandler | 1 | The handler for the request. |
| "webSessionManager" | WebSessionManager | 0..1 | The manager for WebSession's exposed through a method on ServerWebExchange. DefaultWebSessionManager by default. |
| "serverCodecConfigurer" | ServerCodecConfigurer | 0..1 | For access to HttpMessageReader's for parsing form data and multipart data that’s then exposed through methods on ServerWebExchange. ServerCodecConfigurer.create() by default. |
| "localeContextResolver" | LocaleContextResolver | 0..1 | The resolver for LocaleContext exposed through a method on ServerWebExchange. AcceptHeaderLocaleContextResolver by default. |

<a name="Yi2a9"></a>
### Web MVC VS. WebFlux
| 核心组件 | Spring Web MVC | Spring WebFlux |
| --- | --- | --- |
| 前端控制器(Front Controller) | DispatcherServlet | DispatcherHandler |
| Handler 请求映射 | o.s.w.servlet.HandlerMapping | o.s.w.reactive.HandlerMapping |
| Handler 请求适配器 | o.s.w.servlet.HandlerAdapter | o.s.w.reactive.HandlerAdapter |
| Handler 异常处理器 | o.s.w.servlet.HandlerExceptionResolver | HandlerResult.exceptionHandler |
| 视图处理器 | o.s.w.servlet.ViewResolver | o.s.w.reactive.r.v.ViewResolver |
| Locale 解析器 | o.s.w.servlet.LocaleResolver LocaleContextResolver | LocaleContextResolver |
| @Enable模块注解 | @EnableWebMvc | @EnableWebFlux |
| 自定义配置器 | WebMvcConfigurer | WebFluxConfigurer |
| 内容协商配置器 | ContentNegotiationConfigurer | RequestedContentTypeResolverBuilder |
| 内容协商管理器 | ContentNegotiationManager | 无 |
| 内容协商策略 | ContentNegotiationStrategy | RequestedContentTypeResolver |
| 资源跨域注册器 | o.s.w.servlet.c.a.CorsRegistry | o.s.w.reactive.c.CorsRegistry |
| HanderMethod参数解析器 | o.s.w.m.s.HandlerMethodArgumentResolver | o.s.w.reactive.r.m.HandlerMethodArgumentResolver |
| HanderMethod 返回值解析器 | HandlerMethodReturnValueHandler | HandlerResultHandler |
|  |  |  |
|  |  |  |

<a name="NHC1V"></a>
## 执行流程
<a name="QU1G4"></a>
### 核心组件初始化流程
![image-20180821090849670.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1692015043925-73942c4f-4d50-4a45-80b9-6a74a6eee393.png#averageHue=%23f5f5f5&clientId=u27630e6e-227a-4&from=paste&id=u2e576a79&originHeight=493&originWidth=1296&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=91875&status=done&style=none&taskId=u51ac3ea5-8d8c-435d-8693-8707edacfac&title=)
<a name="mw1bC"></a>
### 核心组件请求处理流程
<a name="T0eHL"></a>
#### 注解驱动 （[Annotated Controllers](https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-controller)）组件请求处理流程
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1692014945642-52c9fd02-3179-4de1-bbe9-eb8322ef7880.png#averageHue=%23f6f6f6&clientId=u27630e6e-227a-4&from=paste&id=u9750b8a9&originHeight=513&originWidth=1241&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=54536&status=done&style=none&taskId=u52694c19-f5f7-4636-b3be-421e30b8551&title=)<br />与 Spring Web MVC 流程类似
<a name="vQuEs"></a>
#### 函数式端点（[Functional Endpoints](https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-fn)）组件请求处理流程
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1692014953067-0f6a7ee4-d6d4-493a-a381-c162c2df284e.png#averageHue=%23f5f5f5&clientId=u27630e6e-227a-4&from=paste&id=u3ded8a1b&originHeight=483&originWidth=1116&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51234&status=done&style=none&taskId=u025249a8-85ba-4d26-8289-e6bcf20671b&title=)
<a name="Tucdg"></a>
## 使用场景
<a name="sTRGr"></a>
### 性能考虑
<a name="Tn9R0"></a>
#### [Spring 官方说明](https://docs.spring.io/spring/docs/5.0.8.RELEASE/spring-framework-reference/web-reactive.html#webflux-performance)
Performance has many characteristics and meanings. Reactive and non-blocking generally do not make applications run faster. They can, in some cases, for example if using the WebClient to execute remote calls in parallel. On the whole it requires more work to do things the non-blocking way and that can increase slightly the required processing time.<br />The key expected benefit of reactive and non-blocking is the ability to scale with a small, fixed number of threads and less memory. That makes applications more resilient under load because they scale in a more predictable way. In order to observe those benefits however you need to have some latency including a mix of slow and unpredictable network I/O. That’s where the reactive stack begins to show its strengths and the differences can be dramatic.
<a name="VqdLo"></a>
#### [JHipster WebFlux 性能测试报告](https://blog.ippon.tech/spring-5-webflux-performance-tests/)
<a name="L6bZZ"></a>
##### 基于 MySQL 的 JHipster 应用
![image-20180821091941502.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1692014983831-cdce08ef-70e5-48b7-ae23-93ce30b471ad.png#averageHue=%23e8e6e5&clientId=u27630e6e-227a-4&from=paste&id=ub626beb0&originHeight=624&originWidth=1081&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=282333&status=done&style=none&taskId=ue99858ca-ccf3-411d-9e39-c2aac8fa788&title=)
<a name="LHKlz"></a>
##### 基于 Mongo 的 JHipster 应用
![image-20180821092016981.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1692014987202-608f04f1-ff1e-4d6c-b09f-3280f7f95bf4.png#averageHue=%23e9e8e7&clientId=u27630e6e-227a-4&from=paste&id=uc0d8a440&originHeight=659&originWidth=1068&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=300065&status=done&style=none&taskId=u694aab9d-346e-4d4c-a484-c2c15108220&title=)
<a name="ajQGy"></a>
##### 结论

- 没有明显的速度提升（甚至性能结果稍微更恶劣）

_No improvement in speed was observed with our reactive apps (the Gatling results are even slightly worse)._

- 关注编程用户友好性，Reactive 编程尽管没有新增大量的代码，然而编码（和调试）却是变得更为复杂

_Concerning user-friendliness, reactive programming does not add a lot of new code, but it certainly is a more complex way of coding (and debugging…). A quick Java 8 refresher might be required._

- 现在面临的最大问题是缺少文档。在生成测试应用中，它已经给我们造成了最大障碍，并使得我们可能已经缺少了关键点。因此，我们并不会太快地投入 Reactive 编程，同时等待关于它的更多反馈。因此，Spring WebFlux 尚未证明自身明显地优于 Spring MVC。

_The main problem right now is the lack of documentation. It has been our greatest obstacle in generating test apps, and we may have missed a crucial point because of that.We therefore advise not to jump too quickly on reactive programming and wait for more feedback. Spring WebFlux has not yet proved its superiority over Spring MVC._
<a name="gzmkq"></a>
# [RSocket](https://rsocket.io/)
