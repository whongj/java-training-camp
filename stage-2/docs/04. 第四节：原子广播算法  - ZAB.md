# **摘要**

Zab是我们为ZooKeeper协调服务设计的一种崩溃恢复原子广播算法。ZooKeeper实现了主备份方案，其中主进程执行客户端操作，并使用Zab将相应的增量状态更改传播到备份进程1。由于增量状态更改依赖于先前生成的更改序列，Zab必须保证，如果它交付了给定的状态更改，则必须首先交付它所依赖的所有其他更改。由于初选可能会失败，尽管初选失败，Zab必须满足这一要求。使用ZooKeeper的应用程序需要服务的高性能，因此，一个重要目标是一次拥有多个出色的客户端操作。Zab通过保证最多一个主节点能够广播状态更改并将其合并到状态中，以及在建立新的主节点时使用同步阶段，实现多个未完成的状态更改。在此同步阶段完成之前，新的主节点不会广播新的状态更改。最后，Zab使用状态更改的识别方案，使流程能够轻松识别丢失的更改。此功能是高效恢复的关键。迄今为止的生产实验和经验表明，我们的设计能够实现满足应用程序性能要求的实现。我们的Zab实现可以实现每秒数万次的广播，这对于我们的Web规模应用程序等要求苛刻的系统来说已经足够了。
# 介绍
原子广播是分布式计算中常用的原语，ZooKeeper是另一个使用原子广播的应用程序。ZooKeeper是一种高度可用的协调服务，用于生产Web系统，如Yahoo!在Crawler工作了三年多。这些应用通常包含大量的进程，并依赖于ZooKeeper来完成重要的协调任务，如可靠地存储配置数据和保持运行进程的状态。考虑到大型应用程序对ZooKeeper的依赖，该服务必须能够屏蔽故障并从故障中恢复。�

ZooKeeper是一个复制的服务，它要求大多数(或者更一般的是一个仲裁)服务器没有崩溃。与以前的崩溃恢复协议一样，崩溃的服务器能够恢复并重新加入集成。ZooKeeper采用主备模式来保证副本进程状态的一致性。使用ZooKeeper，主进程接收所有传入的客户端请求，执行它们，并使用Zab (ZooKeeper原子广播协议)将产生的不可交换的增量状态更改以事务的形式传播到备份副本。在主程序崩溃时，进程执行恢复协议，在恢复常规操作之前商定一个公共一致的状态，并建立一个新的主程序来传播状态更改。要发挥主要作用，一个进程必须得到一定数量进程的支持。由于进程可能会崩溃和恢复，随着时间的推移，可能会出现多个主进程，事实上，同一个进程可能会多次使用主进程角色。为了随着时间的推移区分不同的主节点，我们将实例值与每个已建立的主节点关联起来。一个给定的实例值最多映射到一个进程。注意，我们的实例概念与组通信[8]的视图有一些相同的属性，但也有一些关键的区别。通过组通信，给定视图中的所有进程都能够进行广播，当任何进程加入或离开时，都会发生配置更改。使用Zab，只有当主实例崩溃或失去仲裁支持时，进程才会更改为新的视图(或主实例)。

Zab设计的关键是观察到每个状态变化相对于前一个状态是递增的，因此对状态变化的顺序有一种隐性依赖。因此，状态更改不能以任意顺序应用，关键是要确保交付给定主服务器生成的状态更改的前缀并将其应用于服务状态。状态更改是幂等的，只要应用顺序与交付顺序一致，多次应用相同的状态更改就不会导致不一致。因此，保证至少一次语义就足够了，并简化了实现。Zab作为ZooKeeper核心的关键组件，必须有良好的性能。ZooKeeper的一些应用包含了大量的进程，并且广泛地使用了ZooKeeper。以前的系统被设计为协调长期和不频繁的应用程序状态变化。我们设计的ZooKeeper具有高吞吐量和低延迟，因此应用程序可以在集群环境中广泛使用它:具有大量良好连接节点的数据中心。然而，在设计ZooKeeper时，我们发现很难孤立地对原子广播进行推理。应用程序有必须满足的需求和目标，在应用程序中推理原子广播可以实现不同的协议元素，甚至是有趣的优化。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1677223650790-55f2e444-1072-47f8-a093-e5cf51415ffb.png#averageHue=%23efefef&clientId=u78186efe-c6a9-4&from=paste&id=u93b02ac9&name=image.png&originHeight=576&originWidth=734&originalType=binary&ratio=2&rotation=0&showTitle=false&size=75478&status=done&style=none&taskId=u62e77265-8f62-4938-b495-a2fc3233b03&title=)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1677223661688-a8b87e40-f7ef-4a9d-97e3-71cce833e5f5.png#averageHue=%23f2f2f1&clientId=u78186efe-c6a9-4&from=paste&id=udd33cec7&name=image.png&originHeight=448&originWidth=727&originalType=binary&ratio=2&rotation=0&showTitle=false&size=71025&status=done&style=none&taskId=udaac8e6d-8bdf-4851-b1d1-b89406f8433&title=)
多个未完成的事务:在我们的设置中，重要的是我们启用多个未完成的ZooKeeper操作，并且ZooKeeper客户端并发提交的操作前缀是根据FIFO顺序提交的。然而，实现复制状态机的传统协议(如Paxos[2])并没有直接启用这种特性。如果primary单独提出事务，那么学习到的事务的顺序可能不满足顺序依赖关系，因此学习到的事务的顺序不能不经修改地使用。这个问题的一个已知解决方案是将多个事务批处理到单个Paxos提案中，并且一次最多有一个未完成的提案。这种设计会对吞吐量或延迟产生不利影响，具体取决于批处理大小的选择。图1说明了我们在需求下发现的Paxos问题。它显示了带有三个不同提议者的运行，这违反了我们对生成状态更改顺序的要求。提议者P1对序列号27和28执行阶段1。它建议在投票编号为1的第二阶段中分别为序列号为27和28的值A和B。这两个提议都只被接受者A1接受。提议者P2针对受体A2和A3执行阶段1，并最终在阶段2中对投票编号为2的序列27提出提案C。最后，提议者P3执行阶段1和2，并且能够有一个仲裁的受体选择C为序列号27,B为序列号28,D为序列号29。这样的运行是不可接受的，因为B所代表的状态变化因果依赖于a，而不依赖于C。因此，如果序列号i已经选择了a，则只能选择序号i+1的B，而不能在B之前选择C，因为B所代表的状态变化不能与C交换，只能应用在a之后。�

**高效恢复**:我们设置的一个重要目标是从主要崩溃中高效恢复。为了快速恢复，我们使用事务标识方案，使新的主服务器能够以简单的方式确定使用哪个事务序列来恢复应用程序状态。在我们的方案中，事务标识符是一对值:一个实例值和一个给定事务在主进程为该实例广播的序列中的位置。在此方案下，只有接受了具有最高标识符的事务的进程才可以将事务复制到新的主进程，而不需要恢复其他事务。这一观察结果表明，新的主进程能够通过从quorum中每个进程收集最高的事务标识符来决定恢复哪些事务以及从哪个进程恢复事务。

对于使用Paxos进行恢复，只有进程接受值的最后一个序列号是不够的，因为进程可能对每个序列号接受不同的值(具有不同的选票号)。因此，新的主服务器必须对所有之前的序列号执行阶段1，这些序列号的主服务器还没有学习到一个值(或者在我们的上下文中是一个事务)。�

**贡献总结**:我们在这里描述了Zab的设计，这是一个用于ZooKeeper协调服务的原子广播协议。Zab是一种用于主备份系统的高性能原子广播协议。与以前的原子广播协议相比，Zab满足了一组不同的正确性属性。特别地，我们提出了一个称为主序的属性，它对主-备系统很重要。此属性对于随着时间的推移启用状态更改的正确顺序至关重要，因为不同的流程在执行主要角色的同时允许多个未完成的事务。初等顺序不同于因果顺序，我们将在第三- b节中讨论。鉴于我们使用了主序属性，我们说Zab是一个PO原子广播协议。最后，与Paxos等经典算法相比，我们的识别事务的方案可以更快地恢复，因为Zab事务标识符最多映射到一个事务，并且进程按顺序接受它们。�


# 算法分析
Zab有三个阶段:发现、同步和广播。每个进程一次执行该协议的一个迭代，并且在任何时候，一个进程都可以放弃当前的迭代，并通过继续到阶段1开始一个新的迭代。根据协议，Zab进程可以扮演两个角色:领导者和追随者。leader同时执行主角色，并根据主角色的广播调用顺序提出事务。追随者根据协议的步骤接受交易。领导者也会执行追随者的步骤。每个进程都实现了一个leader oracle, leader oracle提供了潜在leader的标识符。在阶段1中，一个进程咨询它的leader oracle以确定它应该跟随哪个其他进程。如果一个进程的leader oracle确定它是leader，那么它就执行协议的leader步骤。然而，根据其神谕被选为领导者并不足以建立其领导力。要建立领导，流程需要完成同步阶段(阶段2)�
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1677223095616-1ecaa9ce-a507-4c12-a416-a612999f1785.png#averageHue=%23f0eeed&clientId=u78186efe-c6a9-4&from=paste&id=u5020ba27&name=image.png&originHeight=215&originWidth=784&originalType=binary&ratio=2&rotation=0&showTitle=false&size=53758&status=done&style=none&taskId=u3aed1b7d-99bb-49bb-8586-ba5390dc6aa&title=)
在Zab的相位描述和后面的分析中，我们使用以下符号:定义IV.1。(历史)每个追随者f都有一个接受交易的历史hf。历史是一个序列。IV.2定义。(初始历史)纪元e的初始历史，即，是e的未来领导者在纪元e第一阶段结束时的历史。(广播值)βe是由主ρe使用abcast广播的交易序列(h v, zi)。协议的三个阶段如下:阶段1(发现):追随者f和领导者执行以下步骤:步骤f.1.1追随者在CEPOCH(f.p)消息中向未来领导者发送其最后一个承诺。步骤' .1.1当从quorum Q的追随者接收到CEPOCH(e)消息时，未来的领导者'向Q中的追随者提出NEWEPOCH(e0)，纪元号e0比在CEPOCH(e)消息中接收到的任何e都要晚。步骤f.1.2一旦接收到来自未来领导者'的NEWEPOCH(e0)，如果f.p < e0，则使f.p←e0并承认新时代提案NEWEPOCH(e0)。确认ACK-E(f。A, hf)包含从者的当前纪元f.a及其历史。追随者完成阶段1。一旦它收到Q中每个追随者的确认，它会选择Q中一个追随者f的历史作为初始历史Ie0。追随者f是这样的，对于Q中的每个追随者f0, f0 .a < f.a或(f0 .a = f.a)∧(f0 .zxid  z f.zxid)。未来的领导者完成第一阶段。第二阶段(同步):追随者f和领导者'执行以下步骤:步骤' .2.1准领导者'向q中的所有追随者提出NEWLEADER(e0, Ie0)消息。步骤f.2.1当从'收到NEWLEADER(e0, T)消息时，如果f.p 6 = e0，追随者开始新的迭代。如果f.p = e0，则它自动执行以下操作:1)将f.a设置为e0;2)对于每一个h v, zi∈Ie0，它接受h e0,h v, zii，并使hf = t。最后，它向leader承认NEWLEADER(e0, Ie0)的提议，从而接受t中的事务。步骤' .2.2当收到一定数量的follower对NEWLEADER(e0, Ie0)的确认后，leader向所有follower发送提交消息，完成阶段2。步骤f.2.2收到leader的提交消息后，按照Ie0的顺序，对Ie0中的每一个事务h v, zi调用abdeliver(h v, zi)，交付初始历史Ie0中的所有事务，完成阶段2。阶段3(广播):追随者f和领导者'执行以下步骤:步骤' .3.1:领导者'按照zxid的递增顺序向Q中的所有追随者提出建议，这样对于每个建议�

# ZAB 算法细节
在我们的Zab实现中，一个Zab进程可以寻找一个leader (ELECTION状态)、following (following状态)或leading (leading状态)。当进程启动时，它将进入ELECTION状态。在这种状态下，这个过程试图选举一个新的领导者或成为一个领导者。如果进程找到了一个当选的领导者，它将移动到FOLLOWING状态并开始跟随领导者。状态为“FOLLOWING”的进程为“follower”。如果进程被选为leader，它将移动到LEADING状态并成为leader。假设一个引导过程也跟随，那么状态LEADING和FOLLOWING就不是排他性的。如果追随者发现领导者失败或放弃领导，它就会过渡到选举，而领导者一旦发现支持其领导的追随者不再达到法定人数，它就会过渡到选举。基本的交付协议在精神上类似于没有中止的两阶段提交[16]。主程序以FIFO顺序选择要广播的值，并创建事务h v, zi。在接收到广播交易的请求时，leader按照交易的zxid的顺序提出he,h v, zii。追随者们接受了这个提议，并通过向领导者发送ACK(e,h v, zi)来表示确认。注意，follower在将提议写入本地稳定存储之前不会将确认发送回。当法定人数的进程接受了提议时，领导者发出一个COMMIT(e,h v, zi)。当进程收到提议的提交消息时
