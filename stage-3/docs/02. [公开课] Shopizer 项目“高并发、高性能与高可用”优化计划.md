> > - 性能评估：测试 Shopizer 后台服务 API 性能， 汇总多维度 API 性能报告（RT、TPS、QPS、内存、CPU 和 I/O 等）
> - 重构评估：结合 API 性能报告，评估店铺、类目、商品、用户、购物车等模块功能
> - 优化清单：列举架构优化清单，包括：服务进程、注册中心、服务调用、数据库、分布式事件、API 网关、分布式缓存、分布式锁、分布式文件系统、配置中心、监控平台等


<a name="llYP9"></a>
# 性能调优
> 内容来源：[https://en.wikipedia.org/wiki/Performance_tuning](https://en.wikipedia.org/wiki/Performance_tuning)

性能调优是对系统性能的改进。通常在计算机系统中，这种活动的动机被称为性能问题，它可以是真实的，也可以是预期的。大多数系统将以一定程度的性能下降来响应增加的负载。系统接受更高负载的能力称为可伸缩性，而修改系统以处理更高负载是性能调优的同义词。<br />系统调优遵循以下步骤：

1. 评估问题并建立数值，对可接受的行为进行分类。
2. 在修改前测量系统的性能。
3. 确定系统中对提高性能至关重要的部分。这被称为瓶颈。
4. 修改系统的该部分以消除瓶颈。
5. 测量修改后系统的性能。
6. 如果修改使性能更好，就采用它。如果修改使其性能更差，就恢复原状。

这是从质量保证的角度来衡量评估改进学习周期的一个例子。<br />性能问题可能由缓慢或无响应的系统识别。这通常是因为系统负载高，导致系统的某些部分的响应能力达到极限。系统内的这种限制被称为瓶颈。<br />一些技术被用来提高性能。其中包括代码优化、负载平衡、缓存策略、分布式计算和自调优。

<a name="TDwqV"></a>
## 性能分析
性能分析，通常称为评测，是使用程序执行时收集的信息来调查程序的行为。它的目标是确定要优化程序的哪些部分。<br />探查器是一种性能分析工具，用于测量程序执行时的行为，特别是函数调用的频率和持续时间。性能分析工具至少从20世纪70年代初就已经存在。档案器可以根据其输出类型或数据收集方法进行分类。

<a name="fd4F5"></a>
## 性能工程
性能工程是一门学科，包括角色、技能、活动、实践、工具和可交付成果，用于满足设计系统的非功能要求，如增加业务收入、减少系统故障、延迟项目以及避免不必要的资源或工作使用。<br />在不同的方法中确定了一些共同的活动：

- 关键业务流程的识别。
- 在用例和系统容量分析中对过程进行详细说明。
- 系统构建，包括性能调优。
- 已构建系统的部署。
- 服务管理，包括系统部署后执行的活动。

<a name="Tf1RM"></a>
## 代码优化
一些优化包括改进代码，使工作在循环之前而不是在循环内部完成一次，或者将对简单选择排序的调用替换为对更复杂的快速排序算法的调用。

<a name="kUW03"></a>
## 配置优化
现代软件系统，例如大数据系统，包括几个框架（例如Apache Storm、Spark、Hadoop）。这些框架中的每一个都公开了数百个配置参数，这些参数在很大程度上影响了这些应用程序的性能。一些优化（调优）包括提高应用程序的性能，为此类应用程序找到最佳配置。

<a name="jBGA8"></a>
## 缓存策略
缓存是消除由于数据访问缓慢而导致的性能瓶颈的一种基本方法。缓存通过在高速内存中保留常用信息、减少访问时间和避免重复计算来提高性能。在引用局部性原则适用的情况下，缓存是提高性能的一种有效方式。用于确定哪些数据存储在速度逐渐加快的存储中的方法统称为缓存策略。例如ASP.NET缓存、CPU缓存等。

<a name="iZfyH"></a>
## 负载均衡
一个系统可以由独立的组件组成，每个组件都能够为请求提供服务。如果所有请求都由这些系统中的一个（或少量）提供服务，而其他系统保持空闲，那么等待使用的系统可用的时间就浪费了。将所有系统平等使用的安排称为负载平衡，可以提高整体性能。<br />负载平衡通常用于通过基于所有潜在候选者的繁忙程度以及每台机器对需要执行的操作类型的适合程度来智能地选择运行操作的机器，从而从分布式系统中获得进一步的收益。

<a name="AGyKX"></a>
## 分布式计算
分布式计算被用于增加在现代CPU架构上并行执行的潜力。继续，分布式系统的使用对于从可用的并行性中获得性能优势至关重要。高性能集群计算是分布式系统用于提高性能的一种众所周知的用途。<br />分布式计算和集群可能会对延迟产生负面影响，同时增加共享资源（如数据库系统）的负载。为了最大限度地减少延迟并避免瓶颈，分布式计算可以从分布式缓存中受益匪浅。

<a name="QpaWh"></a>
## 自我调优
自校正系统能够优化其自身的内部运行参数，以便最大化或最小化目标函数的实现；通常是效率的最大化或误差的最小化。自调谐系统通常表现出非线性自适应控制。自校正系统几十年来一直是航空航天工业的标志，因为这种反馈对于非线性过程的最优多变量控制是必要的。

<a name="H2Thg"></a>
## 性能瓶颈
瓶颈是系统中处于满负荷状态的部分。系统的其他部分将处于空闲状态，等待其执行任务。<br />在发现和消除瓶颈的过程中，重要的是在采取行动消除瓶颈之前，通过采样等方式证明瓶颈的存在。猜测的诱惑很大。猜测往往是错误的，只投资于猜测本身就可能成为一个瓶颈。

<a name="TkSyx"></a>
# 性能测试
<a name="T5IEC"></a>
## 负载测试
负载测试是最简单的性能测试形式。负载测试通常是为了了解系统在特定预期负载下的行为。该负载可以是在设置的持续时间内在应用程序上执行特定数量事务的预期并发用户数量。此测试将给出所有重要业务关键型事务的响应时间。在测试期间，数据库、应用程序服务器等也会受到监控，这将有助于识别安装软件的应用程序软件和硬件中的瓶颈。

<a name="wo3FV"></a>
## 压力测试
压力测试通常用于了解系统内的容量上限。进行这种测试是为了确定系统在极端负载方面的稳健性，并帮助应用程序管理员确定如果当前负载远高于预期的最大负载，系统是否能充分执行。

<a name="HhZcw"></a>
## 浸泡测试
浸泡测试，也称为耐久性测试，通常用于确定系统是否能够承受连续的预期负载。在浸泡测试期间，监视内存利用率以检测潜在的泄漏。同样重要但经常被忽视的是性能下降，即确保在长时间的持续活动后的吞吐量和/或响应时间与测试开始时一样好或更好。它本质上涉及在一段延长的、重要的时间内对系统施加重要的负载。目标是发现系统在持续使用下的行为。

<a name="k9P4L"></a>
## 尖峰测试
尖峰测试是通过突然增加或减少大量用户产生的负载，并观察系统的行为来完成的。目标是确定性能是否会受到影响，系统是否会失败，或者它是否能够处理负载的急剧变化。
<a name="KPfMt"></a>
# 性能指标
<a name="IBFu9"></a>
## TPS
在一个非常通用的意义上，术语每秒事务数（TPS）指的是某个实体每秒执行的原子操作的数量。在一个更受限制的视图中，DBMS供应商和用户社区通常使用该术语来指代每秒执行的数据库事务的数量。当事务更复杂时，可以使用每分钟事务数。<br />最近，这个词也被用来描述加密货币的交易率，例如运行比特币区块链的分布式网络。能够扩展到现实世界交易量的交易率的开发是加密货币技术研究的一个重要领域。

<a name="JTtfr"></a>
## QPS
每秒查询量（QPS）是衡量信息检索系统（如搜索引擎或数据库）在一秒钟内接收到的搜索流量的指标。该术语更广泛地用于任何请求-响应系统，在该系统中，它可以更正确地称为每秒请求（RPS）。<br />高流量系统必须注意QPS，以便知道何时进行扩展以处理更大的负载。

<a name="QNm5K"></a>
## 响应时间（RT）
响应时间是响应服务请求所需的总时间。该服务可以是任何东西，从内存提取到磁盘IO，再到复杂的数据库查询，或者加载完整的网页。暂时忽略传输时间，响应时间是服务时间和等待时间的总和。服务时间是完成您要求的工作所需的时间。对于给定的请求，服务时间随着工作负载的增加而变化不大——要做X量的工作，总是需要X量的时间。等待时间是请求在得到服务之前必须在队列中等待的时间，它从零（不需要等待）到服务时间的很大倍数不等，因为许多请求已经在队列中，必须首先得到服务。<br />通过基本的排队理论数学，您可以计算出当提供服务的设备从0-100%繁忙时，平均等待时间是如何增加的。随着设备变得更忙，平均等待时间以非线性方式增加。设备越忙，当你接近100%繁忙时，响应时间的增加就越明显；所有这些增加都是由等待时间的增加引起的，等待时间是所有在队列中等待的请求必须首先运行的结果。<br />当您的请求和由此产生的响应必须通过网络传输时，传输时间会被添加到响应时间中，这可能非常重要。传输时间可以包括由于距离（光速是有限的）导致的传播延迟、由于传输错误导致的延迟以及数据通信带宽限制（尤其是在最后一英里）降低了请求或回复的传输速度。


<a name="leZAc"></a>
# Java 性能
在软件开发中，编程语言Java在历史上被认为比速度最快的第三代类型语言（如C和C++）慢。主要原因是不同的语言设计，编译后，Java程序在Java虚拟机（JVM）上运行，而不是像C和C++程序那样作为本地代码直接在计算机处理器上运行。性能是一个令人担忧的问题，因为在Java语言在20世纪90年代末和21世纪初迅速流行之后，许多商业软件都是用Java编写的。<br />自20世纪90年代末以来，通过引入实时编译（JIT）（1997年针对Java 1.1）、添加支持更好的代码分析的语言功能以及JVM中的优化（例如HotSpot在2000年成为Sun JVM的默认值），Java程序的执行速度显著提高。Java字节码的硬件执行，如ARM的Jazelle提供的，也被探索以提供显著的性能改进。<br />Java字节码编译的Java程序的性能取决于主机Java虚拟机（JVM）对其给定任务的最佳管理程度，以及JVM在这样做时利用计算机硬件和操作系统（OS）功能的程度。因此，任何Java性能测试或比较都必须始终报告所用JVM的版本、供应商、操作系统和硬件架构。以类似的方式，等效的本地编译程序的性能将取决于其生成的机器代码的质量，因此测试或比较还必须报告所用编译器的名称、版本和供应商，以及其激活的编译器优化指令。


<a name="Y5a09"></a>
## 虚拟机优化方式
随着时间的推移，许多优化都提高了JVM的性能。然而，尽管Java通常是第一个成功实现它们的虚拟机，但它们也经常被用于其他类似的平台。

<a name="xQO9U"></a>
### JIT 编译
早期的JVM总是解释Java字节码。与普通应用程序中的C相比，Java的性能损失在10到20倍之间。为了解决这个问题，Java 1.1中引入了一个实时（JIT）编译器。由于编译成本高，Java 1.2中引入了一个名为HotSpot的附加系统，并将其作为Java 1.3中的默认系统。使用该框架，Java虚拟机不断分析频繁或重复执行的热点的程序性能。然后，这些都是针对优化的，从而以最小的开销实现高性能执行，从而实现性能关键代码。一些基准测试显示，通过这种方式，速度提高了10倍。然而，由于时间限制，编译器无法完全优化程序，因此生成的程序比本机代码替代方案慢。

<a name="hgAJK"></a>
### 自适应优化
自适应优化是计算机科学中的一种方法，它根据当前执行配置文件对程序的各个部分进行动态重新编译。通过简单的实现，自适应优化器可以简单地在实时编译和解释指令之间进行权衡。在另一个级别上，自适应优化可以利用本地数据条件来优化分支并使用内联扩展。<br />像HotSpot这样的Java虚拟机也可以对以前的JITed代码进行去优化。这允许执行激进的（和潜在的不安全的）优化，同时仍然能够在以后对代码进行去优化并返回到安全的路径。

<a name="gE6rp"></a>
### 垃圾回收（Garbage collection）
1.0和1.1的Java虚拟机（JVM）使用了标记扫描收集器，该收集器可以在垃圾收集后对堆进行分段。从Java1.2开始，JVM变成了一个世代收集器，它具有更好的碎片整理行为。现代JVM使用了多种方法，这些方法进一步提高了垃圾收集性能。

<a name="v6jQm"></a>
### 其他优化方式
<a name="fXw5b"></a>
#### 压缩指针（Compressed Oops）
压缩的Oops允许Java 5.0+使用32位引用寻址高达32 GB的堆。Java不支持访问单个字节，只支持默认情况下对齐8字节的对象。因此，堆引用的最低3位将始终为0。通过将32位引用的分辨率降低到8字节块，可寻址空间可以增加到32 GB。与使用64位引用相比，这显著减少了内存使用，因为Java比C++等某些语言使用引用更多。Java 8支持更大的对齐，例如16字节对齐，以支持高达64 GB的32位引用。

<a name="oYzD1"></a>
#### 拆分字节码验证
在执行类之前，Sun JVM验证其Java字节码（请参阅字节码验证器）。这种验证是惰性地执行的：只有当特定的类被加载并准备好使用时，类的字节码才会被加载和验证，而不是在程序开始时。然而，由于Java类库也是常规的Java类，因此在使用它们时也必须加载它们，这意味着Java程序的启动时间通常比C++程序更长。<br />Java平台MicroEdition（J2ME）中首次引入了一种名为split-time verification的方法，该方法自Java版本6以来一直在JVM中使用。它将Java字节码的验证分为两个阶段：<br />设计时–将类从源代码编译为字节码时<br />运行时–加载类时。<br />在实践中，该方法通过捕获Java编译器所具有的类流知识并用类流信息的概要注释编译后的方法字节码来工作。这并没有明显降低运行时验证的复杂性，但确实允许一些快捷方式。

<a name="qTVcg"></a>
#### 逃逸分析和锁粗化
Java能够在语言级别管理多线程。多线程是一种允许程序同时执行多个进程的方法，从而在具有多个处理器或内核的计算机系统上生成更快的程序。此外，即使在执行长时间运行的任务时，多线程应用程序也可以保持对输入的响应。<br />然而，使用多线程的程序需要格外注意线程之间共享的对象，当其中一个线程使用共享方法或块时，锁定对这些方法或块的访问。由于所涉及的底层操作系统级操作的性质，锁定块或对象是一项耗时的操作<br />由于Java库不知道多个线程将使用哪些方法，因此在多线程环境中，标准库总是在需要时锁定块。<br />在Java 6之前，虚拟机在程序要求时总是锁定对象和块，即使一个对象没有被两个不同的线程同时修改的风险。例如，在这种情况下，在每次加法操作之前都会锁定一个局部向量，以确保它不会被其他线程修改（向量是同步的），但因为它对方法来说是严格的局部向量，所以这是不必要的：
```java
public String getNames() {
     Vector<String> v = new Vector<>();
     v.add("Me");
     v.add("You");
     v.add("Her");
     return v.toString();
}

public Vector<String> getVector() {
     Vector<String> v = new Vector<>();
     v.add("Me");
     v.add("You");
     v.add("Her");
     return v;
} 

public void doVector() { // 100 万次
   Vector<String> vector = getVector(); #1 -> T1 #2 -> T2
   for(...){
       
   }
}

public void doVectorAsync(){ // 假设开关开启， 1000001 次执行异步
    Vector<String> vector = getVector();

    ThreadPoolExecutor#execute( () ->{
        vector.add("...");
    });
}

```
从Java 6开始，只有在需要时才会锁定代码块和对象，因此在上述情况下，虚拟机根本不会锁定Vector对象。<br />从6u23版本开始，Java就包含了对逃逸分析的支持。

<a name="K7CwO"></a>
#### 寄存器分配提升
在Java6之前，寄存器的分配在客户端虚拟机中非常原始（它们不跨块），这在可用处理器寄存器较少的CPU设计中是一个问题，如x86s。如果没有更多的寄存器可用于操作，编译器必须从寄存器复制到内存（或从内存复制到寄存器），这需要时间（寄存器的访问速度要快得多）。但是，服务器虚拟机使用了一个颜色图分配器，并且没有这个问题。<br />在Sun的JDK6中引入了寄存器分配的优化；然后可以跨块使用相同的寄存器（如果适用），从而减少对内存的访问。这导致一些基准的业绩增长约60%。

CPU 时钟（Clocks） > 寄存器（Register）> CPU 缓存（Cache）> 内存（Memory）> 外存（Disk）
<a name="vuzXI"></a>
#### 类数据共享
类数据共享（Sun称之为CDS）是一种减少Java应用程序启动时间并减少内存占用的机制。安装JRE后，安装程序会将系统JAR文件（包含所有Java类库的JAR文件，称为rt.JAR）中的一组类加载到一个专用的内部表示中，并将该表示转储到一个称为“共享档案”的文件中。在随后的JVM调用过程中，这个共享档案被映射到内存中，从而节省了加载这些类的成本，并允许在多个JVM进程之间共享这些类的大部分JVM元数据。<br />对于小程序来说，启动时间的相应提高更为明显。

<a name="Rw0iI"></a>
### Java 优化历史
<a name="uIGz2"></a>
#### JDK 1.1.6：首次实时编译（JIT编译器）
<a name="KJFkP"></a>
#### J2SE 1.2：分代收集器的使用
<a name="QKsC9"></a>
#### J2SE 1.3：由HotSpot实时编译
<a name="CbVgz"></a>
#### Java SE 5.0：类数据共享
<a name="XW9Iu"></a>
#### Java SE 6

- 拆分字节码验证
- 逃逸分析和锁粗化
- 寄存器分配提升
- 其他改进
   - Java OpenGL Java 2D管道速度改进
   - Java 2D性能在Java 6中也得到了显著改进
<a name="bmqFl"></a>
##### Java SE 6 Update 10

- Java Quick Starter通过在操作系统启动时在磁盘缓存上预加载JRE数据的一部分来减少应用程序启动时间。
- 当JRE未安装时，执行从web访问的应用程序所需的平台部分现在首先下载。完整的JRE是12 MB，典型的Swing应用程序只需要下载4 MB即可启动。然后在后台下载其余部分。
- 通过在默认情况下广泛使用Direct3D，并在图形处理单元（GPU）上使用着色器来加速复杂的Java 2D操作，提高了Windows上的图形性能。
<a name="bhzAO"></a>
#### Java 7
Java 7已经发布了一些性能改进：计划在Java 6或Java 7的更新中进行未来的性能改进：

- 根据目前在达芬奇机器（多语言虚拟机）上完成的原型设计工作，为动态编程语言提供JVM支持
- 通过管理多核处理器上的并行计算来增强现有的并发库
- 允许JVM在同一会话中同时使用客户端和服务器JIT编译器，方法称为分层编译：
   - 客户端将在启动时使用（因为它擅长启动和小型应用程序）
   - 服务器将用于应用程序的长期运行（因为它在这方面优于客户端编译器）
- 将现有的并发低暂停垃圾收集器（也称为并发标记扫描（CMS）收集器）替换为一个名为“垃圾优先”（G1）的新收集器，以确保随着时间的推移暂停一致。


<a name="Kjgyh"></a>
# Shopzier 项目

<a name="lrLQp"></a>
## API 列表
[https://app.swaggerhub.com/apis-docs/shopizer/shopizer-rest-api/3.0.1](https://app.swaggerhub.com/apis-docs/shopizer/shopizer-rest-api/3.0.1)


增大内存前 TQS ：7.6<br />1 C , 1 GB<br />增大内存后 TQS ：10.2 -> 100<br />2 C , 4GB

