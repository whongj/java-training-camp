# 介绍

## 什么是 Raft
Raft是一种易于理解的共识算法。它在容错和性能方面相当于Paxos。不同之处在于它被分解成相对独立的子问题，并且干净地解决了实际系统所需的所有主要问题。我们希望Raft能够为更广泛的受众提供共识，并且更广泛的受众将能够开发比现在更高质量的基于共识的系统。

Raft是管理复制的共识算法日志（事件、记录）。它产生的结果相当于（多）Paxos，并且它和Paxos一样高效，但结构不同来自 Paxos；这使得Raft比Raft更容易理解 Paxos，也为构建实用系统提供了更好的基础。为了提高可理解性，Raft将共识的关键要素分开，例如领导者选举，日志复制和安全，并强制执行更强的一致性，以减少数量必须考虑的状态。用户研究的结果证明Raft比学生更容易学习 Paxos。Raft还包括一种新的改变机制集群成员资格，使用重叠的多数来保证安全。

## 什么是共识
共识是容错分布式系统的一个基本问题。共识涉及多个服务器就数值达成一致。一旦他们就数值做出决定，这个决定是最终的。当大多数服务器可用时，典型的共识算法会取得进展；例如，即使2台服务器发生故障，5台服务器的集群也可以继续运行。如果更多服务器失败，它们将停止进展（但永远不会返回不正确的结果）。
共识通常出现在复制状态机的背景下，这是构建容错系统的一般方法。每个服务器都有一个状态机和一个日志。状态机是我们想要容错的组件，例如哈希表。在客户端看来，即使群集中的少数服务器发生故障，它们也会与单个可靠的状态机进行交互。每个状态机从其日志中获取输入命令。在我们的哈希表示例中，日志将包括类似于将x设置为3的命令。共识算法用于同意服务器日志中的命令。共识算法必须确保如果任何状态机将x设置为3作为第n个命令，则不会有其他状态机应用不同的第n个命令。结果，每个状态机处理相同系列的命令，从而产生相同系列的结果并到达相同系列的状态。

## 背景
共识算法允许收集机器作为一个连贯的团体，能够在一些成员的失败中幸存下来。正因为如此，它们扮演了一个
在构建可靠的大规模软件系统中发挥关键作用。Paxos 在过去十年中主导了关于共识算法的讨论：大多数实现
共识是基于Paxos或受其影响的，并且Paxos已成为教授共识的主要工具。
不幸的是，Paxos很难理解尽管进行了许多尝试以使其更加平易近人。此外，它的体系结构需要复杂的变化支持实际系统。结果，系统构建者和学生都在 Paxos 中挣扎。在我们自己与Paxos挣扎之后，我们开始着手找到一种新的共识算法，可以为系统建设和教育提供更好的基础。我们的方法是不寻常的，因为我们的主要目标是不可理解的：我们能否为实际系统并以重要的方式描述它-比Paxos更容易学习？此外，我们希望该算法有助于直觉的发展这对于系统构建者至关重要。重要的是只是为了算法的工作，但为了清楚为什么它有效。
这项工作的结果是一个称为 Raft。在设计Raft时，我们应用了特定的技术提高可理解性，包括分解（Raft）分离领导者选举，日志复制和安全）和状态空间缩减（相对于Paxos，Raft减少了不确定的程度以及服务器之间的一致性。有43名学生的用户学习两所大学的研究表明Raft要容易得多要理解比Paxos：学习两种算法后，其中33名学生能够回答有关比关于Paxos的问题更好。
Raft 在许多方面与现有的共识算法相似（最值得注意的是，Oki和Liskov的观点复制，但它有几个新颖的功能：

- 强大的领导者：Raft使用比其他共识算法更强的领导者形式。例如，日志条目仅从领导者流向其他服务器。这简化了复制日志的管理并使Raft更容易理解。
- 领导者选举：Raft使用随机定时器选举领导人。这只增加了少量的任何人已经需要的心跳机制共识算法，同时简单快速地解决冲突。
- 成员资格变更：Raft的机制更改群集中的服务器集使用新的联合共识的方法，其中多数两种不同的配置在转换过程中重叠。这允许集群继续运行通常在配置更改期间。

我们相信Raft在教育目的和作为一个实施基础。它比其他算法更简单，更难以理解；它的描述足以满足实际系统的需求；它有几个开源实现并被使用几家公司；其安全性能已得到严格规定和验证；其效率与其他算法相当。

# 状态复制机（Replicated state machines）
共识算法通常出现在复制状态机。在这种方法中，状态机在一组服务器上计算相同的副本处于相同状态，即使有些的服务器已关闭。复制状态机用于解决分布式系统中的各种容错问题。例如，大规模的系统
有一个单一的集群领导者，如GFS，HDFS，和RAMCloud，通常使用单独的复制状态机器管理领导者选举并存储必须在领导者崩溃后幸存的配置信息。复制状态机的例子包括Chubby和 Zookeeper。
通常实现复制状态机使用复制日志，如图1所示。每个服务器存储包含一系列命令的日志状态机按顺序执行。每个日志包含相同的命令以相同的顺序排列，因此每个状态机处理相同的命令序列。自从状态机是确定性的，每个计算相同的状态和相同的输出顺序。保持复制的日志一致是共识算法。服务器上的共识模块接收来自客户端的命令并将它们添加到其日志中。它与其他共识模块进行通信服务器，以确保每个日志最终包含，即使某些服务器发生故障，也会以相同的顺序进行相同的请求。正确复制命令后，每个服务器的状态机按日志顺序处理它们，并将输出返回给客户端。结果，服务器出现形成一台高度可靠的状态机。通常用于实际系统的共识算法
具有以下属性：

- 它们确保在所有非拜占庭条件下的安全（永远不会返回错误的结果），包括网络延迟，分区和数据包丢失，重复和重新排序。
- 只要有大多数服务器都是可操作的，可以相互通信和客户端通信。因此，一个典型的五台服务器集群可以容忍故障任何两台服务器。服务器被假定为失败停止；他们后来可能会从稳定状态中恢复过来存储并重新加入集群。
- 它们不依赖于时间来确保日志的一致性：错误的时钟和极端的信息最糟糕的是，延迟会导致可用性问题。
- 在常见情况下，命令可以完成为一旦大部分集群响应了单轮远程程序调用；少数慢速服务器不需要影响整体系统性能。
# Raft 共识算法
Raft通过首先选择一个有区别的领导者来实现共识，然后让领导者完全负责管理复制的日志。领导者接受记录来自客户端的条目，在其他服务器上复制它们，并告诉服务器何时安全地应用日志条目他们的状态机。拥有领导者简化了复制日志的管理。例如，领导者可以决定在日志中放置新条目的位置，而不影响其他服务器，并以简单的方式传输数据从领导者到其他服务器。领导者可能会失败或与其他服务器断开连接，在这种情况下，一位新领导人当选。
鉴于领导方法，Raft将共识问题分解为三个相对独立的子文件，这些子文件将在下面的小节中讨论：

- 领导者选举：现有领导者失败时必须选择新领导者
- 日志复制：领导者必须接受来自客户端的日志条目并将其复制到集群中，强迫其他日志同意自己的日志
- 安全性：Raft的关键安全属性是图3中的状态机安全属性：如果任何服务器已将特定日志条目应用于其状态机，则没有其他服务器可以应用不同的命令对于相同的日志索引。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676471494134-0bd7281c-d362-4ee9-bfcb-a90f472a0268.png#averageHue=%23e6e6e6&clientId=uddd076c5-9ec1-4&from=paste&id=u70c4859a&name=image.png&originHeight=616&originWidth=695&originalType=binary&ratio=2&rotation=0&showTitle=false&size=144071&status=done&style=none&taskId=u2fb6bf17-3642-450c-b692-b6923d4abdb&title=)
## 算法关键属性
### 服务器状态
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676466250224-1142a778-c983-4b27-8811-9df14c4e7623.png#averageHue=%23f5f4f2&clientId=uddd076c5-9ec1-4&from=paste&id=ucaec79bf&name=image.png&originHeight=805&originWidth=670&originalType=binary&ratio=2&rotation=0&showTitle=false&size=196799&status=done&style=none&taskId=u90feb621-581c-4427-ae21-1da9bfad6cf&title=)
### 投票请求 RPC
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676466436934-52cb3974-4644-4824-8f5b-e1f74a4c57d2.png#averageHue=%23f6f4f3&clientId=uddd076c5-9ec1-4&from=paste&id=uae530c22&name=image.png&originHeight=507&originWidth=669&originalType=binary&ratio=2&rotation=0&showTitle=false&size=127967&status=done&style=none&taskId=ua53b4837-7393-4720-b86a-ae430b4d9ae&title=)
### 日志条目追加 RPC
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676466381768-ec297ec2-1534-40b0-b1fe-3569452cc71d.png#averageHue=%23f5f3f2&clientId=uddd076c5-9ec1-4&from=paste&id=u68323eb3&name=image.png&originHeight=858&originWidth=670&originalType=binary&ratio=2&rotation=0&showTitle=false&size=213184&status=done&style=none&taskId=uffa27a7b-b20a-4d8e-88ee-7826a2414a8&title=)
### 服务器规则
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676466530962-88acb440-8c7f-47ce-b9e4-6384048f42a5.png#averageHue=%23f5f3f1&clientId=uddd076c5-9ec1-4&from=paste&height=1154&id=u25a1b0bb&name=image.png&originHeight=754&originWidth=439&originalType=binary&ratio=2&rotation=0&showTitle=false&size=169247&status=done&style=none&taskId=u58c24c37-cd67-45dc-8c53-5f0b19e5557&title=&width=672)
## Raft 基础
Raft集群包含多个服务器；五个是一个典型的数字，它允许系统容忍两个故障。在任何给定的时间，每个服务器处于三种状态之一：领导者，追随者或候选人

- 在正常操作中，只有一个领导者，所有其他服务器都是追随者
- 追随者是被动的：他们自己不发布任何请求，而只是回应领导者和候选人的请求。领导者处理所有客户请求（如果客户联系追随者，则跟随者将其重定向到领导者）
- 第三个状态，候选人，是用来选择一个新的领导者

![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676473720370-86283de5-1379-4791-8553-35a5a29b146e.png#averageHue=%23e5e5e5&clientId=uddd076c5-9ec1-4&from=paste&id=ua9aef2fc&name=image.png&originHeight=431&originWidth=656&originalType=binary&ratio=2&rotation=0&showTitle=false&size=102741&status=done&style=none&taskId=u0015130f-c486-4e1a-9e1d-d8788603d41&title=)
Raft将时间划分为任意长度的任期。任期用连续整数编号。每个任期都以选举开始，其中一名或多名候选人试图成为领导者。如果候选人赢得选举，那么它将成为其余任期的领导者。在某些情况下，选举将导致分裂投票。在这种情况下，该任期将以无领导者结尾；新任期（新当选）即将开始。Raft确保在给定的任期中最多有一个领导者。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676473767470-a9116b56-8f2f-45f9-8aca-f286052f61ed.png#averageHue=%23eaeaea&clientId=uddd076c5-9ec1-4&from=paste&id=uee6ad05b&name=image.png&originHeight=401&originWidth=658&originalType=binary&ratio=2&rotation=0&showTitle=false&size=75809&status=done&style=none&taskId=u1e549fc2-3f3b-453c-a896-c4c5fd8d6d6&title=)
不同的服务器可能会观察到任期在不同的时间，在某些情况下，服务器可能不会出席选举甚至整个任期。任期
充当Raft中的逻辑时钟，它们允许服务器检测陈旧的信息，例如陈旧的领导者。每个服务器存储当前的任期号，该任期号增加随着时间的推移单调。当前的任期被交换每当服务器通信时；如果一个服务器的当前任期比对方小，然后更新当前的任期值越大。如果候选人或领导者发现它的任期过时了，它立即恢复到较低的状态。如果服务器收到一个陈旧任期的请求号码，它拒绝了请求。
Raft服务器使用远程过程调用（RPC）进行通信，基本共识算法仅需要两种类型的RPC。请求投票RPC由候选人在选举期间启动，附加条目RPC由领导者启动，以复制日志并提供一种心跳形式。第三种RPC用于传输快照服务器之间。服务器如果没有及时收到回复，请重试RPC，并且并行发布RPC以获得最佳性能。

## 领导者选举（Leader Election）
Raft使用心跳机制触发领导者选举。当服务器启动时，它们开始作为追随者。只要服务器从领导者或候选人那里收到有效的RPC，服务器就会保持跟随状态。领导者向所有追随者发送定期心跳（附加条目RPC，不携带日志条目）以保持其权限。如果跟随者在一段时间内没有接收到称为选择超时的通信，则假设没有可用的领导者并开始选择新的领导者的选举。

要开始选举，追随者会增加其当前任期并过渡到候选状态。然后它为自己投票，并与集群中的每个其他服务器并行发布请求投票RPC。候选人继续处于这种状态，直到发生以下三件事之一：

- 赢得选举
- 另一个服务器确立自己为领导者
- 一段时间没有赢家。

如果候选人收到来自整个集群中大多数服务器的相同期限的投票，则赢得选举。每个服务器将在给定期限内以先到先得的方式投票给最多一名候选人。多数规则确保最多一名候选人可以赢得特定任期的选举。一旦候选人赢得选举，它就成为领导者。然后它向所有其他服务器发送心跳消息，以建立其权力并防止新的选举。

在等待投票的同时，候选人可以接收来自声称是领导者的另一个服务器的附加条目RPC。如果领导者的任期（包含在其RPC中）至少与候选人的现任任期一样大，那么候选人将领导者视为合法并返回追随者状态。如果RPC中的任期小于候选人的当前任期，则候选人拒绝RPC并继续处于候选状态。�

第三个可能的结果是候选人既不会赢得也不会失去选举：如果许多追随者同时成为候选人，投票可以分裂，这样就没有候选人获得多数。发生这种情况时，每个候选人将退出并通过增加其任期并启动另一轮投票RPC开始新的选举。但是，如果没有额外的措施，分裂投票可以无限期地重复。Raft使用随机选举时间来确保分裂投票很少，并且可以快速解决。为了首先防止分裂投票，从固定间隔（例如，150-300ms）随机选择选举超时。这会扩展服务器，因此在大多数情况下，只有一个服务器会超时；它赢得选举并在任何其他服务器超时之前发送心跳。相同的机制用于处理分裂投票。每个候选人在选举开始时重新开始随机选择超时，并在开始下一次选举之前等待超时时间；这减少了新选举中再次投票的可能性。

选举是一个如何理解指导我们在设计方案之间选择的例子。最初，我们计划使用排名系统：为每个候选人分配一个唯一的排名，用于在竞争候选人之间进行选择。如果候选人发现另一个排名较高的候选人，它将返回追随者状态，以便排名较高的候选人可以更容易地赢得下一次选举。我们发现这种方法在可用性方面产生了微妙的问题（如果排名较高的服务器失败，排名较低的服务器可能需要超时并再次成为候选人，但如果这样做太快，它可以重置选择领导者的进度）。我们多次对算法进行了调整，但每次调整后都会出现新的角落情况。最终我们得出结论，随机重试方法更明显，更容易理解。

## 日志复制（Log Replication）
一旦领导者当选，它就开始为客户请求提供服务。每个客户端请求都包含一个由复制状态机执行的命令。领导者将命令作为新条目添加到其日志中，然后起诉与每个其他服务器并行添加条目RPC以复制该条目。当条目被安全复制时（如下所述），领导者将条目应用于其状态机并将执行结果返回给客户端。如果追随者崩溃或运行缓慢，或者网络数据包丢失，则领导者检索无限期地附加条目RPC（即使在它响应客户端之后），直到所有追随者最终存储所有日志尝试。
日志的组织如图6所示。当领导者接收到条目时，每个日志都会尝试存储状态机命令以及任期编号。日志条目中的任期数字用于检测日志之间的不一致性并确保某些属性。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676516452319-f3c59164-3f32-4519-9589-b470a7970b66.png#averageHue=%23e8e8e7&clientId=u7a11fdf6-2e3c-4&from=paste&id=u3b0727ae&name=image.png&originHeight=663&originWidth=690&originalType=binary&ratio=2&rotation=0&showTitle=false&size=114652&status=done&style=none&taskId=u42affed2-92db-4b6a-8d4c-7947039da00&title=)
每个日志条目还具有整数索引，用于标识其在日志中的位置。领导者决定何时将日志应用于状态机是安全的；这样的条目被称为提交（committed）。Raft保证承诺的条目是持久的，并最终由所有可用的状态机执行。一旦创建该条目的领导者将其复制到大多数服务器上（例如，图6中的条目7），就会提交日志条目。这也会提交领导者日志中的所有前面的条目，包括之前领导者创建的条目。第5.4节讨论了在领导者变更后应用此规则时的一些细微之处，并且还表明这种承诺的定义是安全的。领导者跟踪已知承诺的最高索引，并在未来的附录RPC（包括心跳）中包含该索引，以便其他服务器最终发现。一旦跟随者知道日志条目已提交，它就会将该条目应用于其本地状态机（按日志顺序）。

我们设计了 Raft 日志机制，以保持不同服务器上日志之间的高度一致性。这不仅简化了系统的行为并使其更具可预测性，而且是确保安全的重要组成部分。Raft保持以下适当的联系，它们共同构成图3中的对数匹配属性：

- 如果不同日志中的两个条目具有相同的索引和任期，则它们存储相同的命令
- 如果不同日志中的两个条目具有相同的索引和任期，则日志在前面的所有条目中都是相同的。

第一个属性源于这样一个事实，即领导者在给定任期中最多创建一个具有给定日志索引的条目，并且日志条目永远不会更改其在日志中的位置。第二个属性由条目执行的简单一致性检查保证。当发送附加条目RPC时，领导者在其日志中包含紧接在新条目之前的条目的索引和任期。如果追随者在其日志中找不到具有相同索引和任期的条目，则拒绝新条目。一致性检查作为引导步骤：日志的初始空状态满足日志匹配属性，一致性检查在日志扩展时保留日志匹配属性。因此，每当附加条目成功返回时，领导者就会知道追随者的日志与自己通过新条目登录的日志相同。

在正常操作期间，领导者和追随者的日志保持一致，因此条目一致性检查永远不会失败。但是，领导者崩溃可能会使日志不一致（旧领导者可能未完全复制其日志中的所有条目）。这些不一致可能会加剧一系列领导者和追随者的崩溃。图7显示了追随者日志与新领导者日志的差异方式。跟随者可能缺少领导者上存在的条目，它可能具有领导者上不存在的额外条目，或两者兼而有之。日志中缺少和无关的条目可能涵盖多个任期。在Raft中，领导者通过迫使追随者的日志复制自己的日志来处理不一致之处。这意味着跟随者日志中的冲突条目将被领导者日志中的条目覆盖。第5.4节将显示，当再加上一个限制时，这是安全的。为了使追随者的日志与其自身保持一致，领导者必须找到两个日志同意的最新日志条目，在此之后删除追随者日志中的任何条目，并在该点之后发送追随者的所有领导者条目。所有这些操作都是响应附录RPC执行的一致性检查而发生的。领导者为每个追随者维护一个nextIndex，这是领导者将发送给该追随者的下一个日志条目的索引。当领导者首先生效时，它会将所有nextIndex值初始化为日志中最后一个之后的索引（图7中的11）。如果跟随者的日志与领导者的日志不一致，则附录项一致性检查将在下一个附录项RPC中失败。拒绝后，领导者减少nextIndex并检索附录RPC。最终，nextIndex将达到领导者和跟随者日志匹配的程度。发生这种情况时，AppendEntries将成功，从而删除跟随者日志中的任何冲突条目，并从领导者日志中添加条目（如果有）。一旦附加条目成功，追随者的日志与领导者的日志一致，并且在剩余的时间内将保持这种状态。
> 如果需要，可以优化协议以减少被拒绝的附件RPC的数量。例如，当拒绝附加条目请求时，跟随者可以包括冲突条目的任期和它为该任期存储的第一个索引。有了这些信息，领导者可以减少nextIndex来绕过该任期中的所有冲突条目；每个条目有冲突的条目将需要一个附录RPC，而不是每个条目一个RPC。实际上，我们怀疑这种优化是必要的，因为故障很少发生，并且不太可能有许多不一致的条目。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676534646880-4af3de4d-31f5-45c4-8598-c86c4cdb52c4.png#averageHue=%23e4e3e2&clientId=u4dd610f8-d78b-4&from=paste&id=u062e180f&name=image.png&originHeight=771&originWidth=685&originalType=binary&ratio=2&rotation=0&showTitle=false&size=167123&status=done&style=none&taskId=ucf24a9e2-3dac-44c1-9f16-0da93ad8e1b&title=)
有了这个机制，领导者不需要采取任何特殊行动来恢复日志的一致性。它刚刚开始正常操作，日志会根据附件一致性检查的失败自动收敛。领导者从不覆盖或删除自己日志中的条目（图3中的leader appay-Only属性）。这种日志复制机制展示了第2节中描述的理想共识属性：只要大多数服务器启动，Raft就可以接受，复制和应用新的日志条目；在正常情况下，新条目可以通过单轮RPC复制到大部分集群；一个缓慢的追随者不会影响表现。

## 安全性
前面的部分描述了Raft如何选择领导者并复制日志条目。但是，到目前为止描述的机制还不足以确保每个状态机以相同的顺序执行完全相同的命令。例如，当领导者提交多个日志条目时，追随者可能不可用，然后可以选择领导者并用新条目覆盖这些条目；因此，不同的状态机可能会执行不同的命令序列。本节通过添加对哪些服务器可以被选为领导者的限制来完成Raft算法。该限制确保任何给定任期的领导者包含以前条款中承诺的所有条目（图3中的领导者完整性属性）。鉴于选举限制，我们然后使承诺规则更加精确。最后，我们给出了领导者完整性属性的证明草图，并展示了它如何导致复制状态机的正确行为。
### 选举限制
从当选之日起，每个新领导者都会获得条款，无需将这些条目传送给领导者。这意味着日志条目只能朝着一个方向流动，从领导者到追随者，领导者永远不会覆盖日志中的现有条目。Raft使用投票过程来防止候选人赢得选举，除非其日志包含所有承诺的条目。候选人必须联系大多数群集才能被选中，这意味着每个承诺的条目必须存在于这些服务器中的至少一个中。如果候选人的日志至少与该多数日志中的任何其他日志一样最新（其中“最新”的定义正好在下面），那么它将保存所有已提交的条目。RequestVote RPC实现了这一限制：RPC包含有关候选人日志的信息，如果自己的日志比候选人的日志更新，选民否认其投票。Raft通过比较日志中最后一个条目的索引和任期来确定两个日志中的哪个是最新的。如果日志中的最后一个条目具有不同的任期，则带有后面任期的日志是最新的。如果日志以相同的任期结尾，则任何日志较长的日志都是最新的。

### 从前条目提交条目
图8说明了旧日志条目存储在大多数服务器上但仍可能被未来领导者覆盖的情况。为了消除像图8中那样的问题，Raft从不通过计算副本来提交以前条款中的日志条目。只有领导者当前任期的日志条目才能通过计算副本来提交；一旦以这种方式提交了当前任期的条目，则由于日志匹配属性，所有先前条目都将间接提交。在某些情况下，领导者可以安全地得出结论，提交较旧的日志条目（例如，如果该条目存储在每个服务器上），但Raft为简单起见采取更保守的方法。Raft在承诺规则中引起了这种额外的复杂性，因为当领导者复制先前条款的条目时，日志条目保留其原始任期编号。在其他共识算法中，如果新领导者重新复制先前“任期”中的条目，则必须使用新的“任期编号”进行复制。Raft的方法可以更容易地对日志条目进行推理，因为它们随着时间和日志而保持相同的任期编号。此外，Raft中的新领导者比以前的算法发送更少的日志条目（其他算法必须发送冗余日志条目才能在提交之前对其进行重新编号）。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676537145741-e326cf38-2d8e-43eb-b99b-cf2bd61cb75c.png#averageHue=%23e3e1e1&clientId=u057058f8-b40e-4&from=paste&id=tNBHM&name=image.png&originHeight=805&originWidth=703&originalType=binary&ratio=2&rotation=0&showTitle=false&size=191493&status=done&style=none&taskId=u6e656df2-d541-4841-a59d-acbbce6386e&title=)

### 安全性论证
鉴于完整的Raft算法，我们现在可以更准确地说领导者完整性属性成立（这个论点是基于安全性证明；参见第9.2节）。我们假设领导者完整性属性不成立，那么我们证明了一个矛盾。假设任期T（leaderT）的领导者从其任期中提交了一个日志条目，但日志条目不由未来某个任期的领导者存储。考虑其领导者（leaderU）不存储条目的最小任期U>T。
1.在选择时，leaderU的日志中必须缺少承诺的条目（领导者永远不会删除或覆盖条目）。
2.leaderT复制了大多数集群的条目，leaderU收到了大部分集群的投票。因此，至少有一个服务器（“选民”）都接受了leaderT的条目并投票给leaderU，如图9所示。选民是解决矛盾的关键。
3.在投票leaderU之前，选民必须已接受leaderT提交的条目；否则它将拒绝leaderT的AppendEntries请求（其当前期限将高于T）。
4.选民在为leaderU投票时仍存储该条目，因为每个介入领导者都包含该条目（假设），领导者从不删除条目，而追随者仅在与领导者冲突时删除条目。
5.选民向leaderU投票，因此leaderU的日志必须与选民一样最新。这导致了两个矛盾之一。
6.首先，如果选民和leaderU共享相同的最后一个日志项，那么leaderU的日志必须至少与选民的日志一样长，因此其日志包含选民日志中的每个条目。这是一个矛盾，因为选民包含承诺的条目，并且leaderU被假定为不是.7。否则，leaderU的最后一个日志期限必须大于选民。此外，它大于T，因为选民的最后一个对数项至少为T（它包含任期T中的承诺条目）。创建leaderU最后一个日志条目的早期领导者必须在其日志中包含已提交的条目（通过假设）。然后，通过日志匹配属性，leaderU的日志还必须包含提交的条目，这是一个矛盾。
这就完成了矛盾。因此，大于T的所有任期的领导者必须包含任期T中承诺的任期T的所有条目。
9.日志匹配属性保证未来的领导者还将包含间接承诺的条目，如图8（d）中的索引2。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676551592068-58a55b83-5f8f-4bfe-830d-cfa7e594d34a.png#averageHue=%23efefef&clientId=u35ce0244-e05c-4&from=paste&id=uc0e7a94c&name=image.png&originHeight=415&originWidth=714&originalType=binary&ratio=2&rotation=0&showTitle=false&size=77932&status=done&style=none&taskId=ua13ad08f-502a-4a4f-8787-cb19db1f784&title=)
> 鉴于领导者完整性属性，我们可以从图3中证明状态机安全属性，该属性指出，如果服务器已将给定索引处的日志条目应用于其状态机，则不会有其他服务器应用不同的日志条目为相同的索引。当服务器将日志条目应用于其状态机时，其日志必须与通过该条目的领导者的日志记录相同，并且必须提交该条目。现在考虑任何服务器应用给定日志索引的最低期限；日志完整性属性保证所有较高条款的领导者将存储相同的日志条目，因此以较晚条款应用索引的服务器将应用相同的值。因此，状态机安全性能成立。最后，Raft要求服务器以日志索引顺序应用条目。结合状态机安全属性，这意味着所有服务器将以相同的顺序将完全相同的日志条目集应用于其状态机


### 跟随者和候选者奔溃
到目前为止，我们一直关注领导者的失败。追随者和候选人崩溃比领导者崩溃更容易处理，并且它们都以相同的方式处理。如果追随者或候选人崩溃，那么未来的投票和附加条目发送给它的RPC将失败。Raft通过无限期重新运行来处理这些故障；如果崩溃的服务器重新启动，则RPC将成功完成。如果服务器在完成RPC之后但在响应之前崩溃，那么它将在重新启动后再次接收相同的RPC。筏式RPC是独立的，所以这不会造成伤害。例如，如果追随者收到包含已存在于其日志中的日志条目的附加条目请求，则它忽略新请求中的那些条目。

### 时机和可用性
我们对Raft的要求之一是安全性不得取决于时间：系统不得产生不正确的结果，只是因为某些事件发生的速度或速度比预期的要快或慢。但是，可用性（系统及时响应客户的能力）必然取决于时间安排。例如，如果消息交换花费的时间超过服务器崩溃之间的典型时间，则候选人不会停留足够长的时间以赢得选举；如果没有稳定的领导者，Raft就无法取得进展。领导者选举是Raft的一个方面，时机最为关键。只要系统满足以下时间要求，Raft就能选择并保持稳定的领导者：
broadcastTime ≪ electionTimeout ≪ MTBF
在这个不等式中，broadcastTime是服务器将RPC并行发送到集群中的每个服务器并接收其响应所需的平均时间；electionTimeout是选举超时时间；MTBF是单个服务器的平均故障间隔时间。广播时间应该比选举超时时间短一个数量级，以便领导人能够可靠地发送心跳信息，阻止追随者开始选举；考虑到选举超时采用的随机方法，这种不平等也使得分裂投票不太可能。选择超时应该比MTBF少几个数量级，这样系统才能稳定地运行。当领导人崩溃时，系统将在大约选举超时时间内不可用；我们希望这只代表整个时间的一小部分。

广播时间和MTBF是底层系统的财产，而选择超时是我们必须选择的。Raft的RPC通常要求接收者将信息保存到稳定的存储中，因此广播时间可能从0.5ms到20ms不等，具体取决于存储技术。因此，选举超时可能在10毫秒到500毫秒之间。典型的服务器MTBF为几个月或更长时间，这很容易满足时间要求。


## 集群成员变更
到目前为止，我们假设集群配置（参与共识算法的服务器集）是固定的。在实践中，偶尔需要更改配置，例如在服务器出现故障时更换服务器或更改复制程度。尽管这可以通过使整个集群离线、更新配置文件，然后重新启动集群来完成，但这将使集群在转换期间不可用。此外，如果有任何手动步骤，可能会导致操作员错误。为了避免这些问题，我们决定自动化配置更改，并将其纳入Raft共识算法。

为了确保配置变更机制的安全，在过渡期间，两位领导人不可能在同一任期内当选。不幸的是，任何服务器直接从旧配置切换到新配置的方法都是不安全的。不可能一次自动切换所有服务器，因此在转换过程中集群可能会分裂成两个独立的大多数（见图10）。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676617679560-b14c5a25-ab9f-4451-881c-86dbee64e888.png#averageHue=%23ececec&clientId=u482f353f-3039-4&from=paste&id=ude43dd0a&name=image.png&originHeight=592&originWidth=664&originalType=binary&ratio=2&rotation=0&showTitle=false&size=96653&status=done&style=none&taskId=u9213e614-7400-4ca8-b162-02e7963c432&title=)
为了确保安全，配置更改必须使用两阶段方法。实现这两个阶段有多种方法。例如，一些系统（例如[22]）使用第一阶段来禁用旧配置，从而无法处理客户端请求；则第二阶段启用新配置。在Raft中，集群首先切换到我们称之为联合共识的过渡配置；一旦达成了联合共识，系统就会过渡到新的配置。联合共识结合了新旧配置：

- 日志条目将复制到两种配置中的所有服务器。
- 任一配置中的任何服务器都可以作为领导者。
- 协议（选举和入职承诺）要求新旧双方各占多数配置。

联合共识允许各个服务器在不同的时间在不同的配置之间进行转换，而不会影响安全性。此外，联合共识允许集群在整个配置更改过程中继续为客户端请求提供服务。

集群配置使用复制日志中的特殊条目进行存储和通信；图11说明了配置更改过程。当领导者收到将配置从Cold更改为Cnew的请求时，它将联合共识的配置（Cold，图中为新配置）存储为日志条目，并使用前面描述的机制复制该条目。一旦给定的服务器将新的配置条目添加到其日志中，它将使用该配置进行所有未来的决策（无论条目是否提交，服务器始终使用其日志中的最新配置）。这意味着领导者将使用Cold，new的规则来确定何时提交Cold，new的日志条目。如果领导者崩溃，则可以根据获胜候选人是否获得了Cold，new来选择Cold或Cold，new。无论如何，Cnew在此期间不能做出单方面决定。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1676620034070-68e1d3fa-929b-4c2c-90c5-ad5ae8e9a37f.png#averageHue=%23e9e9e8&clientId=u482f353f-3039-4&from=paste&id=u2b074093&name=image.png&originHeight=577&originWidth=668&originalType=binary&ratio=2&rotation=0&showTitle=false&size=123199&status=done&style=none&taskId=uae1ebde5-82ad-4e70-899f-16295df2460&title=)
一旦提交了新的Cold，任何Cold或Cnew都不能在未经另一方批准的情况下做出决定，Leader Completeness属性确保只有具有Cold的新日志条目的服务器才能被选为Leader。现在，领导者可以安全地创建一个描述Cnew的日志条目，并将其复制到集群中。同样，此配置将在看到后立即在每个服务器上生效。当根据Cnew规则提交了新配置时，旧配置无关紧要，不在新配置中的服务器可以关闭。如图11所示，Cold和Cnew都不可能做出单方面决定；这保证了安全。

重新配置还有三个问题需要解决。第一个问题是，新服务器最初可能不会存储任何日志条目。如果以这种状态将它们添加到集群中，它们可能需要很长时间才能赶上，在此期间可能无法提交新的日志条目。为了避免可用性差距，Raft在配置更改之前引入了一个额外的阶段，在该阶段中，新服务器作为无投票权成员加入集群（领导者向其复制日志条目，但大多数情况下不考虑这些条目）。一旦新服务器赶上了集群的其余部分，就可以如上所述进行重新配置。

第二个问题是集群领导者可能不是新配置的一部分。在这种情况下，一旦提交了Cnew日志条目，领导者就会下台（返回到跟随者状态）。这意味着，当领导者管理一个不包含自己的集群时，会有一段时间（在提交Cnew时）；它复制日志条目，但不计入大多数。提交Cnew时会发生引线转换，因为这是新配置可以独立运行的第一点（始终可以从Cnew中选择引线）。在此之前，可能只有来自Cold的服务器才能当选领导人。

第三个问题是移除的服务器（不在Cnew中的服务器）可能会破坏集群。这些服务器不会接收心跳，因此它们将超时并开始新的选举。然后，他们将发送带有新任期号的RequestVote RPC，这将导致现任领导人恢复为追随者状态。最终将选出一位新的领导人，但被移除的服务器将再次超时，这一过程将重复，导致可用性较差。

为了防止此问题，当服务器认为当前领导人存在时，会忽略RequestVote RPC。具体而言，如果服务器在当前领导人听证会的最小选举超时内收到RequestVote RPC，则不会更新其任期或授予其投票权。这不会影响正常的选举，其中每个服务器在开始选举之前至少等待一个最小的选举超时。然而，它有助于避免被移除的服务器造成的中断：如果一个领导者能够获得集群的心跳，那么它就不会被更大的任期数所取代。

## 日志压缩（Log compaction）
Raft的日志在正常操作期间会增长，以合并更多的客户端请求，但在实际系统中，它无法无限制地增长。随着日志的增长，它占用了更多的空间，需要更多的时间来回放。如果没有某种机制丢弃日志中积累的过时信息，这最终会导致可用性问题。快照是最简单的压缩方法。在快照拍摄中，整个当前系统状态被写入稳定存储上的快照，然后直到该点的整个日志被丢弃。捕捉用于Chubby和ZooKeeper，本节的其余部分描述了Raft中的快照。

# 条目
[raft.pdf](https://www.yuque.com/attachments/yuque/0/2023/pdf/222258/1676442268385-aa07633d-7da1-4c9b-b12a-cd89460d465c.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F222258%2F1676442268385-aa07633d-7da1-4c9b-b12a-cd89460d465c.pdf%22%2C%22name%22%3A%22raft.pdf%22%2C%22size%22%3A567533%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22udf46a1e6-1ef4-4c85-ba85-375b6595526%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u1426fdb4%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D)

