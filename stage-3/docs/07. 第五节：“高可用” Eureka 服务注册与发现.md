> <a name="V51IV"></a>
#### 主要内容
> - 自我保护机制：理解  Eureka  Server Self Preservation Mode，以及在高可用场景下的价值
> - P2P 协议：掌握  Eureka  Sever 点对点通讯协议的细节
> - Eureka  Sever 调优：优化  Eureka  Server 配置，压测对比调优前后的性能指标
> <a name="X2EuX"></a>
#### 关联内容
> <a name="Yf4RG"></a>
##### 第一期 Java 分布式架构 - 服务治理
> - [第十一节：基于监控指标的负载均衡实现](https://mqu.h5.xeknow.com/sl/28I6Mv)
>    - Netflix
> - [第十二节：基于动态权重的负载均衡实现](第十二节：基于动态权重的负载均衡实现)
>    - Netflix Servo
> <a name="Ndpcz"></a>
##### 第二期 Java 分布式架构 - 模式、设计与实现
> - [第八节：Alibaba Nacos 2.x Distro 算法的运用](https://mqu.h5.xeknow.com/sl/3z0I5I)



<a name="FDIZw"></a>
# Netflix Eureka 简介
Eureka 是一种基于 REST（Representational State Transfer）的服务，主要用于AWS云中，用于定位服务，以实现中间层服务器的负载平衡和故障切换。我们称之为 Eureka 服务器。 Eureka 还附带了一个基于Java的客户端组件 Eureka client，这使得与服务的交互更加容易。客户端还有一个内置的负载均衡器，用于进行基本的循环负载平衡。在Netflix，一个更复杂的负载均衡器将 Eureka 包裹起来，根据流量、资源使用、错误条件等因素提供加权负载平衡，以提供卓越的弹性。

<a name="ZBdJu"></a>
## Eureka 在 Netflix 中的运用
在Netflix， Eureka 除了在中端负载平衡中发挥关键作用外，还用于以下目的：

- 对于Netflix Asgard的红/黑部署，这是一项开源服务，使云部署更容易。 Eureka 与Asgard进行交互，以在出现问题时快速无缝地在旧版本/新版本的服务部署之间切换，特别是考虑到启动100个实例来部署一个版本可能需要很长时间。
- 用于我们的cassandra部署，以使实例脱离流量进行维护。
- 用于我们的memcached缓存服务，以标识环中的节点列表。
- 用于出于各种其他原因携带关于服务的其他附加的特定于应用程序的元数据。

<a name="g0wDr"></a>
## 什么时候使用 Eureka 
您通常在AWS云中运行，并且您有许多中间层服务，您不想向AWS ELB注册或暴露来自外部世界的流量。您要么正在寻找一个简单的循环负载平衡解决方案，要么愿意根据您的负载平衡需求编写自己的 Eureka 包装器。您不需要粘性会话，也不需要将会话数据加载到外部缓存（如memcached）中。更重要的是，如果您的体系结构适合基于客户端的负载均衡器的模式， Eureka 就可以很好地适应这种使用。

<a name="g2OW6"></a>
## Eureka 客户端和服务端如何通讯
通信技术可以是任何你喜欢的东西。Eureka 可以帮助您找到想要与之通信的服务的信息，但不会对通信协议或方法施加任何限制。例如，您可以使用 Eureka 获取目标服务器地址，并使用诸如节俭、HTTP 或任何其他RPC机制之类的协议。

<a name="pMlfG"></a>
##  Eureka 架构
![image.png](https://cdn.nlark.com/yuque/0/2023/png/222258/1688535106183-ca0f098c-f18b-4e28-8940-a90d2e8a448e.png#averageHue=%23eaf1f0&clientId=u63bd50aa-0a23-4&from=paste&id=u60a25330&originHeight=540&originWidth=720&originalType=binary&ratio=2&rotation=0&showTitle=false&size=43651&status=done&style=none&taskId=u549b2d8c-dd18-4b01-8984-4a768b9f175&title=)<br />上面的架构描述了 Eureka 是如何在Netflix部署的，这就是你通常运行它的方式。每个区域有一个 Eureka 集群，它只知道其区域中的实例。每个区域至少有一个 Eureka 服务器来处理区域故障。<br />服务在 Eureka 注册，然后每30秒发送一次心跳以续订租约。如果客户端几次都无法续订租约，则会在大约90秒内将其从服务器注册表中删除。注册信息和续订被复制到集群中的所有 Eureka 节点。来自任何区域的客户端都可以查找注册表信息（每30秒发生一次）来定位他们的服务（可能在任何区域中）并进行远程调用。

<a name="YXpQ1"></a>
## 非 Java 服务和客户端场景
对于非基于Java的服务，您可以选择用服务语言实现 Eureka 的客户端部分，也可以运行“sidecar”，它本质上是一个Java应用程序，带有一个嵌入式 Eureka 客户端，用于处理注册和心跳。基于 REST 的端点还公开了 Eureka 客户端支持的所有操作。非 Java 客户端可以使用 REST 端点来查询有关其他服务的信息。

<a name="i9J1V"></a>
## 配置
使用 Eureka ，您可以动态添加或删除集群节点。您可以将内部配置从超时调整为线程池。 Eureka 使用 [Archius](https://github.com/Netflix/archaius)，如果您有一个配置源代码实现，那么这些配置中的许多都可以动态调整。
> Eureka 原生：Archaius 1.x 基于 Apache Commons Configuration 实现
> Spring Cloud Netflix Eureka：基于 Spring PropertySources 实现

<a name="JuHL5"></a>
## 弹性
在AWS云中，很难不考虑我们构建的每一个东西的弹性。 Eureka 从我们获得的这一经验中受益，客户机和服务器都内置了弹性。<br />Eureka 客户端是为处理一个或多个 Eureka 服务器的故障而构建的。由于 Eureka 客户端中有注册表缓存信息，因此，即使所有 Eureka 服务器都宕机，它们也可以正常运行。
> Nacos 客户端也有类似的设计，Nacos Config 中有持久化的策略

Eureka 服务器对其他 Eureka 同行宕机具有弹性。即使在客户端和服务器之间的网络分区期间，服务器也具有内置的弹性，以防止大规模停机。

<a name="iNarM"></a>
## 多区域
在多个 AWS 区域部署 Eureka 是一项相当简单的任务。区域之间的 Eureka 集群彼此之间没有交流。

<a name="SnrTy"></a>
## 监控
Eureka 使用 [Servo](https://github.com/Netflix/servo/wiki) 来跟踪客户端和服务器中的大量信息，以实现性能、监控和警报。这些数据通常在JMX注册表中可用，并可以导出到 Amazon Cloud Watch。
> Amazon Cloud Watch Micrometer 一种导出源
> [https://micrometer.io/docs/registry/cloudwatch](https://micrometer.io/docs/registry/cloudwatch)


<a name="dZKoC"></a>
# 配置 Eureka
Eureka 有两个组件：Eureka 客户端和 Eureka 服务器。使用 Eureka 的体系结构通常有两个应用程序：

- 应用程序客户端，使用 Eureka 客户端向应用程序服务发出请求。
- 应用程序服务，接收来自应用程序客户端的请求并发回响应。

设置包括以下内容：

- Eureka 服务器
- 应用程序客户端的 Eureka 客户端
- Eureka 应用程序服务客户端

Eureka 可以在 AWS 和非 AWS 环境中运行。 <br />如果您在云环境中运行，则需要传入 Java 命令行属性 `-Deureka.database=cloud`，以便 Eureka Client/Server知道初始化特定于AWS云的信息。

<a name="DhLtL"></a>
## 配置 Eureka 客户端
<a name="lP2Rx"></a>
### 前置条件

- JDK 1.8 后更高版本

您可以选择以下选项来获取 Eureka 客户端二进制文件。总是尝试获得最新版本，因为往往会有更多的修复程序。

- 您可以使用此URL下载Eureka 客户端二进制文件

"[http://search.maven.org/#search%7Cga%7C1%7CEureka-client](http://search.maven.org/#search%7Cga%7C1%7Ceureka-client)"

- 您可以将 Eureka 客户端添加为 Maven 依赖项
```xml
 <dependency>
  <groupId>com.netflix.eureka</groupId>
  <artifactId>eureka-client</artifactId>
  <version>1.1.16</version>
 </dependency>
```
<a name="cFE0r"></a>
### Eureka 客户端配置
配置 Eureka 客户端的最简单方法是使用属性文件。默认情况下，Eureka 客户端在类路径中搜索属性文件Eureka-client.properties。它在特定于环境的特性文件中进一步搜索特定于环境替代。环境通常是测试或生产的，由一个-Deureka.environment Java 命令行开关提供给Eureka 客户端（不带.properties后缀）。因此，客户端还搜索eureka-client-{test，prod}.properties。<br />如果出于某种原因想要更改属性文件的名称，可以在java命令行开关中指定-Deureka.client.props=（不带后缀），其中是要搜索的属性文件的名。<br />文件中的属性说明了它们的用途。至少需要配置以下内容：
```properties
Application Name (eureka.name)
Application Port (eureka.port)
Virtual HostName (eureka.vipAddress)
Eureka Service Urls (eureka.serviceUrls)
```
有关更高级的配置，请查看以下链接中的可用选项：

- [com.netflix.appinfo.EurekaInstanceConfig](https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.java) 
- [com.netflix.discovery.EurekaClientConfig](https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java)

<a name="fVLfr"></a>
#### 实现细节
<a name="hvOrw"></a>
##### Eureka 客户端配置 - EurekaClientConfig

- 内建实现 - com.netflix.discovery.DefaultEurekaClientConfig
- Spring Cloud 实现 - org.springframework.cloud.netflix.eureka.EurekaClientConfigBean

<a name="yQs2z"></a>
##### Eureka 注册实例配置 - EurekaInstanceConfig 

- 内建实现 - com.netflix.appinfo.CloudInstanceConfig
- Spring Cloud 实现 - org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean


<a name="W2tL1"></a>
### 配置 Eureka 服务器
<a name="E8JQb"></a>
### 前置条件

- JDK 1.8 以及更高版本
- Tomcat 6.x 以及更高

使用Eureka 服务器，您可以选择以下选项来获取二进制文件：

- 您可以根据此处指定的源代码构建 [WAR](https://github.com/Netflix/eureka/wiki/Building-Eureka-Client-and-Server) 。
- 您可以使用以下URL从 Maven 中心下载WAR档案：

"[http://search.maven.org/#search%7Cga%7C1%7CEureka-server](http://search.maven.org/#search%7Cga%7C1%7Ceureka-server)"
<a name="kjCMA"></a>
### Eureka 服务器配置 
配置Eureka Server的最简单方法是使用与上述Eureka Client类似的属性文件。首先，按照上面指定的方式配置与服务器一起运行的Eureka 客户端。Eureka Server 本身启动一个 Eureka  客户端，用于查找其他Eureka Server 。因此，您需要首先为 Eureka Server 配置 Eureka  客户端，就像您对连接到 Eureka  服务的任何其他客户端所做的那样。Eureka Server 将使用其 Eureka  客户端配置来识别具有相同名称（即 eureka.name）的对等Eureka Server <br />配置 Eureka  客户端后，如果您在AWS中运行，则可能需要配置Eureka Server 。Eureka 服务器默认在类路径中搜索属性文件 eureka-server.properties。它在特定于环境的特性文件中进一步搜索特定于环境替代。该环境通常是测试或生产的，由到Eureka 服务器的-Deureka.environment Java 命令行开关提供（不带.properties后缀）。相应地，服务器还搜索 eureka-server-{test,prod}.properties。

<a name="ki34K"></a>
#### 配置本地部署
当运行 Eureka 服务器进行本地开发时，通常需要等待大约3分钟，直到它完全启动。这是由于默认的服务器行为，即搜索要同步的对等端，并在找不到可用对等端时重试。可以通过设置属性eureka.numberRegistrySyncRetries=0来减少此等待时间。

<a name="YEdhV"></a>
#### 为 AWS 配置
如本文所述，如果您在AWS中运行，则需要额外的配置。有关更高级的服务器配置，请参阅此处提供的选项。<br />如果您正在构建WAR档案，您可以在eureka-server/conf下编辑文件，并且在创建档案之前，构建会将属性文件放在WEB-INF/classes下。<br />如果您是从 Maven 下载归档文件，那么您可以自己在WEB-INF/classes下合并编辑过的属性文件。
<a name="kz5Nz"></a>
# 理解 Eureka 客户端和服务器通讯
从1.1.153 版开始，引入了 EurekaModule 类，以允许将 Eureka 客户端与governator/guice一起使用。

<a name="XOppZ"></a>
## 关于实例状态
默认情况下，Eureka 客户端以 STARTING 状态启动，这使实例有机会在提供流量之前进行特定于应用程序的初始化。<br />然后，应用程序可以通过将实例状态设置为 UP 来显式地放置该实例以进行通信。
```java
ApplicationInfoManager.getInstance().setInstanceStatus(InstanceStatus.UP)
```
应用程序还可以注册健康检查回调，该回调可以选择性地将实例状态更改为DOWN。<br />在Netflix，我们还使用OUT_OF_SERVICE状态，主要用于排除流量中的一个实例。它用于在出现问题时轻松回滚新修订版的部署。大多数应用程序为新的修订创建一个新的ASG，并且流量被路由到新的ASG。在出现问题的情况下，回滚修订只是通过将ASG中的所有实例设置为OUT_of_SERVICE来关闭流量。

<a name="ysseH"></a>
### 实现细节
<a name="k4vwo"></a>
#### 实例状态枚举 - InstanceStatus
> InstanceStatus 属于 InstanceInfo 的内部枚举类

```java
    public enum InstanceStatus {
        UP, // Ready to receive traffic
        DOWN, // Do not send traffic- healthcheck callback failed
        STARTING, // Just about starting- initializations to be done - do not
        // send traffic
        OUT_OF_SERVICE, // Intentionally shutdown for traffic
        UNKNOWN;
        ...
    }
```


<a name="goUnE"></a>
## Eureka 客户端操作
Eureka 客户端首先尝试与AWS云中同一区域的Eureka 服务器进行所有操作，如果找不到服务器，则故障转移到其他区域。<br />应用程序客户端可以使用Eureka 客户端返回的信息进行负载平衡。下面是一个示例应用程序，它使用Eureka 客户端返回的信息来平衡客户端。
```java
InstanceInfo nextServerInfo = DiscoveryManager.getInstance()
                .getDiscoveryClient()
                .getNextServerFromEureka(vipAddress, false);

        Socket s = new Socket();
        int serverPort = nextServerInfo.getPort();
        try {
            s.connect(new InetSocketAddress(nextServerInfo.getHostName(),
                    serverPort));
        } catch (IOException e) {
            System.err.println("Could not connect to the server :"
                    + nextServerInfo.getHostName() + " at port " + serverPort);
        }

```

如果基本的轮训负载平衡不足以满足您的需要，您可以在这里提供的API/操作之上包装一个负载平衡器。在AWS云中，请确保重试失败并保持较低的超时，因为在某些情况下，Eureka 服务器可能会在中断的情况下返回不再存在的实例。<br />需要注意的是，Eureka 客户端会清理其为服务器通信而创建的空闲时间超过30秒的HTTP连接。这是因为AWS防火墙限制不允许流量在几分钟的空闲时间后通过连接。<br />Eureka 客户端通过以下方式与服务器交互。

<a name="Fos9C"></a>
### 注册
Eureka 客户端将有关正在运行的实例的信息注册到 Eureka 服务器。在AWS云中，有关实例的信息可通过访问URL获得 [http://169.254.169.254/latest/metadata](http://169.254.169.254/latest/metadata.) 注册发生在第一次心跳（30秒后）。
<a name="g5hYJ"></a>
#### 实现细节
<a name="KGba3"></a>
##### Eureka 客户端注册
com.netflix.discovery.DiscoveryClient#register：
```java
    boolean register() throws Throwable {
        logger.info(PREFIX + "{}: registering service...", appPathIdentifier);
        EurekaHttpResponse<Void> httpResponse;
        try {
            httpResponse = eurekaTransport.registrationClient.register(instanceInfo);
        } catch (Exception e) {
            logger.warn(PREFIX + "{} - registration failed {}", appPathIdentifier, e.getMessage(), e);
            throw e;
        }
        if (logger.isInfoEnabled()) {
            logger.info(PREFIX + "{} - registration status: {}", appPathIdentifier, httpResponse.getStatusCode());
        }
        return httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();
    }
```
默认情况，由于 com.netflix.discovery.EurekaClientConfig#shouldEnforceRegistrationAtInit() 方法返回 false，所以 DiscoveryClient#register() 在构造阶段不会被同步调用：
```java
    DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,
                    Provider<BackupRegistry> backupRegistryProvider, EndpointRandomizer endpointRandomizer) {
	...
	if (clientConfig.shouldRegisterWithEureka() && clientConfig.shouldEnforceRegistrationAtInit()) {
            try {
                if (!register() ) {
                    throw new IllegalStateException("Registration error at startup. Invalid server response.");
                }
            } catch (Throwable th) {
                logger.error("Registration error at startup: {}", th.getMessage());
                throw new IllegalStateException(th);
            }
        }
```
因此，Eureka 客户端注册实际通过异步的方式执行，具体通过 com.netflix.discovery.InstanceInfoReplicator 来完成：

1. 初始化 InstanceInfoReplicator 对象
```java
private void initScheduledTasks() {
    ...
	if (clientConfig.shouldRegisterWithEureka()) {
        ...
        // InstanceInfo replicator
        instanceInfoReplicator = new InstanceInfoReplicator(
                this,
                instanceInfo,
                clientConfig.getInstanceInfoReplicationIntervalSeconds(),
                2); // burstSize
    	...
        instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());

	}
}
```

2. 启动调度任务
```java
    public void start(int initialDelayMs) {
        if (started.compareAndSet(false, true)) {
            instanceInfo.setIsDirty();  // for initial register
            Future next = scheduler.schedule(this, initialDelayMs, TimeUnit.SECONDS);
            scheduledPeriodicRef.set(next);
        }
    }
```
其中默认调度执行周期为 30 s，可能的实现：

- com.netflix.discovery.DefaultEurekaClientConfig#getInstanceInfoReplicationIntervalSeconds()
```java
    @Override
    public int getInstanceInfoReplicationIntervalSeconds() {
        return configInstance.getIntProperty(
                namespace + REGISTRATION_REPLICATION_INTERVAL_KEY, 30).get();
    }
```

- org.springframework.cloud.netflix.eureka.EurekaClientConfigBean#getInstanceInfoReplicationIntervalSeconds
```java
	...
	/**
	 * Indicates how often(in seconds) to replicate instance changes to be replicated to
	 * the eureka server.
	 */
	private int instanceInfoReplicationIntervalSeconds = 30;
    ...
	@Override
	public int getInstanceInfoReplicationIntervalSeconds() {
		return instanceInfoReplicationIntervalSeconds;
	}
```

3. 指定调度
```java
    public void run() {
        try {
            discoveryClient.refreshInstanceInfo();

            Long dirtyTimestamp = instanceInfo.isDirtyWithTime();
            if (dirtyTimestamp != null) {
                discoveryClient.register();
                instanceInfo.unsetIsDirty(dirtyTimestamp);
            }
        } catch (Throwable t) {
            logger.warn("There was a problem with the instance info replicator", t);
        } finally {
            Future next = scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);
            scheduledPeriodicRef.set(next);
        }
    }
```
<a name="uHSnT"></a>
### 更新（续约）
Eureka 客户端需要通过每 30 秒发送一次心跳来续订租约。续订通知 Eureka 服务器该实例仍然有效。如果服务器已经 90 秒没有看到续订，它会将该实例从其注册表中删除。建议不要更改续订间隔，因为服务器使用该信息来确定客户端到服务器的通信是否存在广泛的问题。
<a name="BdEDj"></a>
#### 实现细节
<a name="kJ9bg"></a>
##### Eureka 客户端心跳任务
心跳任务是通过 EurekaClient API  TimedSupervisorTask 来实现：
```java
private void initScheduledTasks() {
    ...
	if (clientConfig.shouldRegisterWithEureka()) {
        int renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();
        ...
        // Heartbeat timer
        heartbeatTask = new TimedSupervisorTask(
                "heartbeat",
                scheduler,
                heartbeatExecutor,
                renewalIntervalInSecs,
                TimeUnit.SECONDS,
                expBackOffBound,
                new HeartbeatThread()
        );
    	...
	}
}
```
续订租约时长默认：30 s：
```java
public class LeaseInfo {
    public static final int DEFAULT_LEASE_RENEWAL_INTERVAL = 30;
    ...
    // Client settings
    private int renewalIntervalInSecs = DEFAULT_LEASE_RENEWAL_INTERVAL;    
}
```
具体心跳任务在 HeartbeatThread 中实现：
```java
    private class HeartbeatThread implements Runnable {

        public void run() {
            if (renew()) {
                lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();
            }
        }
    }
	...
    boolean renew() {
        EurekaHttpResponse<InstanceInfo> httpResponse;
        try {
            httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);
            logger.debug(PREFIX + "{} - Heartbeat status: {}", appPathIdentifier, httpResponse.getStatusCode());
            if (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) {
                REREGISTER_COUNTER.increment();
                logger.info(PREFIX + "{} - Re-registering apps/{}", appPathIdentifier, instanceInfo.getAppName());
                long timestamp = instanceInfo.setIsDirtyWithTime();
                boolean success = register();
                if (success) {
                    instanceInfo.unsetIsDirty(timestamp);
                }
                return success;
            }
            return httpResponse.getStatusCode() == Status.OK.getStatusCode();
        } catch (Throwable e) {
            logger.error(PREFIX + "{} - was unable to send heartbeat!", appPathIdentifier, e);
            return false;
        }
    }
```

<a name="sVmN0"></a>
##### TimedSupervisorTask 使用场景

1. 整合 Netflix Servo 来监控 Eureka 客户端应用的监控指标
```java
public class TimedSupervisorTask extends TimerTask {

    private final Counter successCounter;
    private final Counter timeoutCounter;
    private final Counter rejectedCounter;
    private final Counter throwableCounter;
    private final LongGauge threadPoolLevelGauge;

    public TimedSupervisorTask(String name, ScheduledExecutorService scheduler, ThreadPoolExecutor executor,
                               int timeout, TimeUnit timeUnit, int expBackOffBound, Runnable task) {
        ...
        // Initialize the counters and register.
        successCounter = Monitors.newCounter("success");
        timeoutCounter = Monitors.newCounter("timeouts");
        rejectedCounter = Monitors.newCounter("rejectedExecutions");
        throwableCounter = Monitors.newCounter("throwables");
        threadPoolLevelGauge = new LongGauge(MonitorConfig.builder("threadPoolUsed").build());
        Monitors.registerObject(name, this);
    }
    
    @Override
    public void run() {
        ...
        try {
            threadPoolLevelGauge.set((long) executor.getActiveCount());
            ...
            threadPoolLevelGauge.set((long) executor.getActiveCount());
            successCounter.increment();
        } catch (TimeoutException e) {
            ...
            timeoutCounter.increment();
        	...
        } catch (RejectedExecutionException e) {
            ...
            rejectedCounter.increment();
        } catch (Throwable e) {
            ...
            throwableCounter.increment();
        } 
        ...
    }    
}
```

2. 执行限时任务
```java
public class TimedSupervisorTask extends TimerTask {
    ...
    @Override
    public void run() {
        Future<?> future = null;
        try {
            future = executor.submit(task);
            threadPoolLevelGauge.set((long) executor.getActiveCount());
            future.get(timeoutMillis, TimeUnit.MILLISECONDS);  // block until done or timeout
            delay.set(timeoutMillis);
            threadPoolLevelGauge.set((long) executor.getActiveCount());
            successCounter.increment();
        } catch (TimeoutException e) {
            logger.warn("task supervisor timed out", e);
            timeoutCounter.increment();

            long currentDelay = delay.get();
            long newDelay = Math.min(maxDelay, currentDelay * 2);
            delay.compareAndSet(currentDelay, newDelay);

        } catch (RejectedExecutionException e) {
            if (executor.isShutdown() || scheduler.isShutdown()) {
                logger.warn("task supervisor shutting down, reject the task", e);
            } else {
                logger.warn("task supervisor rejected the task", e);
            }

            rejectedCounter.increment();
        } catch (Throwable e) {
            if (executor.isShutdown() || scheduler.isShutdown()) {
                logger.warn("task supervisor shutting down, can't accept the task");
            } else {
                logger.warn("task supervisor threw an exception", e);
            }

            throwableCounter.increment();
        } finally {
            if (future != null) {
                future.cancel(true);
            }

            if (!scheduler.isShutdown()) {
                scheduler.schedule(this, delay.get(), TimeUnit.MILLISECONDS);
            }
        }
    }
}
```
<a name="m17jf"></a>
### 获取注册表
Eureka 客户端从服务器获取注册表信息并将其缓存在本地。之后，客户端使用该信息来查找其他服务。通过获取上一个获取周期和当前获取周期之间的增量更新，定期更新此信息（每30秒）。增量信息在服务器中保存的时间更长（约3分钟），因此增量获取可能会再次返回相同的实例。Eureka 客户端会自动处理重复的信息。<br />在获得delta之后，Eureka 客户端通过比较服务器返回的实例计数来与服务器协调信息，如果由于某种原因信息不匹配，则会再次获取整个注册表信息。Eureka 服务器缓存delta、整个注册表以及每个应用程序的压缩有效载荷以及相同的未压缩信息。有效负载还支持JSON/XML格式。Eureka 客户端使用jersy-apache客户端以压缩的JSON格式获取信息。

<a name="oYCJn"></a>
#### 实现细节
<a name="ejRmo"></a>
##### 获取注册表任务
```java
private void initScheduledTasks() {
        if (clientConfig.shouldFetchRegistry()) {
            // registry cache refresh timer
            int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();
            int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();
            cacheRefreshTask = new TimedSupervisorTask(
                    "cacheRefresh",
                    scheduler,
                    cacheRefreshExecutor,
                    registryFetchIntervalSeconds,
                    TimeUnit.SECONDS,
                    expBackOffBound,
                    new CacheRefreshThread()
            );
            scheduler.schedule(
                    cacheRefreshTask,
                    registryFetchIntervalSeconds, TimeUnit.SECONDS);
        }
        ...
    }
```
默认情况，Eureka 客户端配置是需要获取注册表（shouldFetchRegistry() == true），创建 "cacheRefreshTask" 的 TimedSupervisorTask（任务）。<br />注册表获取调度执行周期默认为：30s，具体任务实现在 CacheRefreshThread 中：
```java
    class CacheRefreshThread implements Runnable {
        public void run() {
            refreshRegistry();
        }
    }

    void refreshRegistry() {
        try {
        	...
            boolean success = fetchRegistry(remoteRegionsModified);
            ...
        } catch (Throwable e) {
            logger.error("Cannot fetch registry from server", e);
        }
    }

    private boolean fetchRegistry(boolean forceFullRegistryFetch) {
        Stopwatch tracer = FETCH_REGISTRY_TIMER.start();

        try {
            // If the delta is disabled or if it is the first time, get all
            // applications
            Applications applications = getApplications();

            if (clientConfig.shouldDisableDelta()
                    || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))
                    || forceFullRegistryFetch
                    || (applications == null)
                    || (applications.getRegisteredApplications().size() == 0)
                    || (applications.getVersion() == -1)) //Client application does not have latest library supporting delta
            {
                logger.info("Disable delta property : {}", clientConfig.shouldDisableDelta());
                logger.info("Single vip registry refresh property : {}", clientConfig.getRegistryRefreshSingleVipAddress());
                logger.info("Force full registry fetch : {}", forceFullRegistryFetch);
                logger.info("Application is null : {}", (applications == null));
                logger.info("Registered Applications size is zero : {}",
                        (applications.getRegisteredApplications().size() == 0));
                logger.info("Application version is -1: {}", (applications.getVersion() == -1));
                getAndStoreFullRegistry();
            } else {
                getAndUpdateDelta(applications);
            }
            applications.setAppsHashCode(applications.getReconcileHashCode());
            logTotalInstances();
        } catch (Throwable e) {
            logger.info(PREFIX + "{} - was unable to refresh its cache! This periodic background refresh will be retried in {} seconds. status = {} stacktrace = {}",
                    appPathIdentifier, clientConfig.getRegistryFetchIntervalSeconds(), e.getMessage(), ExceptionUtils.getStackTrace(e));
            return false;
        } finally {
            if (tracer != null) {
                tracer.stop();
            }
        }

        // Notify about cache refresh before updating the instance remote status
        onCacheRefreshed();

        // Update remote status based on refreshed data held in the cache
        updateInstanceRemoteStatus();

        // registry was fetched successfully, so return true
        return true;
    }
```
fetchRegistry(boolean) 方法存在全量和增量获取方式：

- 全量获取：com.netflix.discovery.DiscoveryClient#getAndStoreFullRegistry
- 增量获取：com.netflix.discovery.DiscoveryClient#getAndUpdateDelta

onCacheRefreshed() 方法会发送 CacheRefreshedEvent 事件：
```java
    protected void onCacheRefreshed() {
        fireEvent(new CacheRefreshedEvent());
    }

    protected void fireEvent(final EurekaEvent event) {
        for (EurekaEventListener listener : eventListeners) {
            try {
                listener.onEvent(event);
            } catch (Exception e) {
                logger.info("Event {} throw an exception for listener {}", event, listener, e.getMessage());
            }
        }
    }
```
注：CacheRefreshedEvent 通常会 30 秒触发一次，无论注册中心的注册表是否有更新，通常可以通过 com.netflix.discovery.shared.Applications#getAppsHashCode() 方法的返回内容来判断注册表是否更新。

<a name="iYNl6"></a>
###### 全量获取注册表 
com.netflix.discovery.DiscoveryClient#getAndStoreFullRegistry：
```java
    private void getAndStoreFullRegistry() throws Throwable {
        long currentUpdateGeneration = fetchRegistryGeneration.get();

        logger.info("Getting all instance registry info from the eureka server");

        Applications apps = null;
        EurekaHttpResponse<Applications> httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == null
                ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())
                : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get());
        ...
    }

```
实际执行的组件是：EurekaTransport 中的 queryClient 对象，如 ：

- 内建实现 - com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient
```java
    @Override
    public EurekaHttpResponse<Applications> getApplications(String... regions) {
        return getApplicationsInternal("apps/", regions);
    }

    @Override
    public EurekaHttpResponse<Applications> getVip(String vipAddress, String... regions) {
        return getApplicationsInternal("vips/" + vipAddress, regions);
    }
```

- Spring Cloud 实现 - RestTemplateEurekaHttpClient
```java
	@Override
	public EurekaHttpResponse<Applications> getApplications(String... regions) {
		return getApplicationsInternal("apps/", regions);
	}

	@Override
	public EurekaHttpResponse<Applications> getVip(String vipAddress, String... regions) {
		return getApplicationsInternal("vips/" + vipAddress, regions);
	}
```
<a name="glpEG"></a>
###### 增量获取注册表 
同理，参考 com.netflix.discovery.DiscoveryClient#getAndUpdateDelta
```java
    private void getAndUpdateDelta(Applications applications) throws Throwable {
        long currentUpdateGeneration = fetchRegistryGeneration.get();

        Applications delta = null;
        EurekaHttpResponse<Applications> httpResponse = eurekaTransport.queryClient.getDelta(remoteRegionsRef.get());
        if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) {
            delta = httpResponse.getEntity();
        }

        if (delta == null) {
            logger.warn("The server does not allow the delta revision to be applied because it is not safe. "
                    + "Hence got the full registry.");
            getAndStoreFullRegistry();
        } 
        ...
    }
```
实际执行的组件是：EurekaTransport 中的 queryClient 对象，如 ：

- 内建实现 - com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient
```java
    @Override
    public EurekaHttpResponse<Applications> getDelta(String... regions) {
        return getApplicationsInternal("apps/delta", regions);
    }
```

- Spring Cloud 实现 - RestTemplateEurekaHttpClient
```java
	@Override
	public EurekaHttpResponse<Applications> getDelta(String... regions) {
		return getApplicationsInternal("apps/delta", regions);
	}
```
<a name="HTctv"></a>
### 取消
Eureka 客户端在关机时向 Eureka 服务器发送取消请求。这将从服务器的实例注册表中删除该实例，从而有效地将该实例排除在流量之外。<br />这是在Eureka 客户端关闭时完成的，应用程序应确保在关闭期间调用以下命令：
```java
DiscoveryClient#shutdown();
```

<a name="KwmGd"></a>
##### 实现细节
<a name="fgyim"></a>
##### 服务实例注销
服务实例注销默认不会主动被调用，而是随着 Eureka 客户端关闭时来调用：
```java
    @PreDestroy
    @Override
    public synchronized void shutdown() {
        if (isShutdown.compareAndSet(false, true)) {
            ...
            // If APPINFO was registered
            if (applicationInfoManager != null
                    && clientConfig.shouldRegisterWithEureka()
                    && clientConfig.shouldUnregisterOnShutdown()) {
                applicationInfoManager.setInstanceStatus(InstanceStatus.DOWN);
                unregister();
            }
        	...
        }
    }

    void unregister() {
        // It can be null if shouldRegisterWithEureka == false
        if(eurekaTransport != null && eurekaTransport.registrationClient != null) {
            try {
                ...
                EurekaHttpResponse<Void> httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId());
            	...
        }
    }
```
注销操作 unregister() 实际使用了 EurekaTransport registrationClient 对象中的 cancel 方法：

- 内建实现 - com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient
```java
    @Override
    public EurekaHttpResponse<Void> cancel(String appName, String id) {
        String urlPath = "apps/" + appName + '/' + id;
        ClientResponse response = null;
        try {
            Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();
            addExtraHeaders(resourceBuilder);
            response = resourceBuilder.delete(ClientResponse.class);
            ...
        }
    }
```

- Spring Cloud 实现 - RestTemplateEurekaHttpClient
```java
	@Override
	public EurekaHttpResponse<Void> cancel(String appName, String id) {
		String urlPath = serviceUrl + "apps/" + appName + '/' + id;

		ResponseEntity<Void> response = restTemplate.exchange(urlPath, HttpMethod.DELETE, null, Void.class);

		return anEurekaHttpResponse(response.getStatusCodeValue()).headers(headersOf(response)).build();
	}
```
cancel 动作均调用 De-register application instance，即 DELETE /eureka/v2/apps/appID/instanceID

> 延伸问题：
> 注销操作 unregister 是在 shutdown 阶段执行的，那么，Eureka Client 应用如何实现优雅停机？
> Provider 应用注册当前实例，在 shutdown 被执行时，而 shutdown 是在服务器关闭阶段执行，该服务实例即将停机。那么，Consumer 应用告知到 Provider 下线至少在 30 秒后，期间的远程调用如何处理？
> 需要扩展来实现 Eureka Client 应用的优化停机，至少实现以下步骤：
> 1. 执行 unregister 操作，可以通过 EurekaTransport registrationClient 的 cancel 方法来实现
> 2. 设置一段静默期，来处理消费端注册表延迟问题所发送请求
> 3. 处理已接受的网络请求
> 4. 需要处理依赖资源关闭，比如 数据库连接池、消息服务、缓存服务
> 5. 执行服务实例下线

<a name="Ka1ak"></a>
## 延迟（Time Lag）
Eureka 客户端的所有操作可能需要一段时间才能反映在 Eureka 服务器上，然后反映在其他 Eureka 客户端上。这是因为 Eureka 服务器上的有效负载被缓存，该服务器被定期刷新以反映新信息。Eureka 的客户也会定期获取 delta。因此，更改可能需要长达2分钟的时间才能传播到 Eureka 的所有客户。

<a name="RF13n"></a>
## Eureka 服务器操作处理
<a name="FSQ9t"></a>
### Eureka 服务器与 Servlet 容器整合
<a name="Doxfw"></a>
#### Eureka 引导程序 - EurekaBootStrap
EurekaBootStrap 基于 Servlet API ServletContextListener 实现，实现 Servlet 应用的生命周期：Servlet 上下文初始化和销毁
<a name="xD72F"></a>
##### Servlet 上下文初始化
```java
    @Override
    public void contextInitialized(ServletContextEvent event) {
        try {
            initEurekaEnvironment();
            initEurekaServerContext();

            ServletContext sc = event.getServletContext();
            sc.setAttribute(EurekaServerContext.class.getName(), serverContext);
        } catch (Throwable e) {
            logger.error("Cannot bootstrap eureka server :", e);
            throw new RuntimeException("Cannot bootstrap eureka server :", e);
        }
    }

    protected void initEurekaEnvironment() throws Exception {
        logger.info("Setting the eureka configuration..");

        String dataCenter = ConfigurationManager.getConfigInstance().getString(EUREKA_DATACENTER);
        if (dataCenter == null) {
            logger.info("Eureka data center value eureka.datacenter is not set, defaulting to default");
            ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);
        } else {
            ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);
        }
        String environment = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT);
        if (environment == null) {
            ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);
            logger.info("Eureka environment value eureka.environment is not set, defaulting to test");
        }
    }

    protected void initEurekaServerContext() throws Exception {
        EurekaServerConfig eurekaServerConfig = new DefaultEurekaServerConfig();

        // For backward compatibility
        JsonXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);
        XmlXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);

        logger.info("Initializing the eureka client...");
        logger.info(eurekaServerConfig.getJsonCodecName());
        ServerCodecs serverCodecs = new DefaultServerCodecs(eurekaServerConfig);

        ApplicationInfoManager applicationInfoManager = null;

        if (eurekaClient == null) {
            EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())
                    ? new CloudInstanceConfig()
                    : new MyDataCenterInstanceConfig();
            
            applicationInfoManager = new ApplicationInfoManager(
                    instanceConfig, new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());
            
            EurekaClientConfig eurekaClientConfig = new DefaultEurekaClientConfig();
            eurekaClient = new DiscoveryClient(applicationInfoManager, eurekaClientConfig);
        } else {
            applicationInfoManager = eurekaClient.getApplicationInfoManager();
        }

        PeerAwareInstanceRegistry registry;
        if (isAws(applicationInfoManager.getInfo())) {
            registry = new AwsInstanceRegistry(
                    eurekaServerConfig,
                    eurekaClient.getEurekaClientConfig(),
                    serverCodecs,
                    eurekaClient
            );
            awsBinder = new AwsBinderDelegate(eurekaServerConfig, eurekaClient.getEurekaClientConfig(), registry, applicationInfoManager);
            awsBinder.start();
        } else {
            registry = new PeerAwareInstanceRegistryImpl(
                    eurekaServerConfig,
                    eurekaClient.getEurekaClientConfig(),
                    serverCodecs,
                    eurekaClient
            );
        }

        PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(
                registry,
                eurekaServerConfig,
                eurekaClient.getEurekaClientConfig(),
                serverCodecs,
                applicationInfoManager
        );

        serverContext = new DefaultEurekaServerContext(
                eurekaServerConfig,
                serverCodecs,
                registry,
                peerEurekaNodes,
                applicationInfoManager
        );

        EurekaServerContextHolder.initialize(serverContext);

        serverContext.initialize();
        logger.info("Initialized server context");

        // Copy registry from neighboring eureka node
        int registryCount = registry.syncUp();
        registry.openForTraffic(applicationInfoManager, registryCount);

        // Register all monitoring statistics.
        EurekaMonitors.registerAllStats();
    }
```
主要执行步骤：

- 初始化 Eureka 服务器配置（Environment）
- 初始化 Eureka 服务器上下文
   - 初始化通讯序列化协议（实现）
      - 老版本 - XStream 处理 JSON 和 XML
      - 新版本 - ServerCodecs 基于 Jackson 处理 JSON 和 XML
   - 初始化 EurekaClient 实例
      - AWS
      - 非 AWS
   - 初始化 PeerAwareInstanceRegistry 实例
      - AWS
      - 非 AWS
   - 初始化 PeerEurekaNodes 实例
      - Eureka 服务器副本节点容器
   - 从其他 Eureka 服务器同步


<a name="s4wpr"></a>
#### Eureka 服务器上下文 - EurekaServerContext

<a name="UuCQW"></a>
#### Eureka 配对节点实例注册中心 - PeerAwareInstanceRegistry
<a name="BVFRP"></a>
##### 同步数据同步 - syncUp()
默认实现 com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#syncUp：
```java
    @Override
    public int syncUp() {
        // Copy entire entry from neighboring DS node
        int count = 0;

        for (int i = 0; ((i < serverConfig.getRegistrySyncRetries()) && (count == 0)); i++) {
            if (i > 0) {
                try {
                    Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());
                } catch (InterruptedException e) {
                    logger.warn("Interrupted during registry transfer..");
                    break;
                }
            }
            Applications apps = eurekaClient.getApplications();
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    try {
                        if (isRegisterable(instance)) {
                            register(instance, instance.getLeaseInfo().getDurationInSecs(), true);
                            count++;
                        }
                    } catch (Throwable t) {
                        logger.error("During DS init copy", t);
                    }
                }
            }
        }
        return count;
    }
```



实例注册中心 - InstanceRegistry<br />查询服务 - LookupService<br />租约管理- LeaseManager

EvictionTask
<a name="mXuZY"></a>
### 注册（Register）
<a name="QSAc0"></a>
### 更新（Renew）
<a name="Y5V2d"></a>
### 获取注册表（Fetch Registry）
<a name="itXGo"></a>
### 自我保护模式（Self Preservation）


<a name="yHOpu"></a>
## 通讯机制
默认情况下，Eureka 客户端使用 [Jersey](http://jersey.java.net/) 和 Jackson 以及 JSON 负载与 Eureka Server 通信。您始终可以通过覆盖默认机制来使用自己选择的机制。请注意，XStream 也是一些遗留用例的依赖关系图的一部分。

<a name="LOvX6"></a>
### Spring Cloud 场景通讯
Spring Cloud Eureka Client 实现会适配 EurekaHttpClient 接口：

- Spring RestTemplate 实现 - org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient
   - 优化点
      - 减少 HttpMessageConverter 数量，一般锁定为一种，FastJSON 或 Jackson
      - 扩展 Http Client 实现 - ClientHttpRequestFactory 实现
         - Http Component 实现等
- Spring 5+ WebClient 实现 - org.springframework.cloud.netflix.eureka.http.WebClientEurekaHttpClient

<a name="fyyAa"></a>
# 服务器自我保护模式
如果 Eureka 服务器检测到超过预期数量的注册客户端以不合理的方式终止了连接，并且同时等待驱逐，则它们将进入自我保护模式。这样做是为了确保灾难性的网络事件不会擦除 Eureka 注册表数据，并将其传播到下游的所有客户端。<br />为了更好地理解自我保护，首先了解 Eureka 客户是如何“结束”他们的注册生命周期的。Eureka 协议要求客户端在永久退出时执行显式注销操作。例如，在提供的 Java 客户端中，这是在 shutdown() 方法中完成的。任何连续 3 次心跳续订（renew）失败的客户端都被认为是不干净的终止，并将被后台驱逐过程驱逐。当当前注册表的15%以上处于这种稍后的状态时，将启用自我保护。<br />当处于自我保护模式时，Eureka 服务器将停止驱逐所有实例，直到：

- 它看到的心跳续订次数又回到了预期阈值以上，或者
- 自我保护被禁用

默认情况下启用自我保护，启用自我保护的默认阈值 > 当前注册表大小的 15%。

<a name="cFZKj"></a>
## 配置自我保护阈值
com.netflix.eureka.DefaultEurekaServerConfig 定义了自我保护配置。要更改示例中的自我保护阈值，请设置属性：eureka.renewalPercentThreshold=[0.0，1.0]。

<a name="xwaFs"></a>
## 失效自我保护
com.netflix.eureka.DefaultEurekaServerConfig 定义了自我保护配置。要在示例中禁用自我保护，请设置属性：eureka.enableSelfPreservation=false。<br />在生产环境中，如果由于某种原因，您的服务器由于合法原因进入了自我保护模式，您可以通过配置临时禁用自我保护，从而强制服务器退出自我保护模式。我们预计，在这些情况下，人类行动正在评估情况并采取适当行动。

<a name="Q2J7O"></a>
# Eureka REST 操作
以下是可供非 Java 应用程序使用Eureka的REST操作。<br />appID是应用程序的名称，instanceID是与实例关联的唯一id。在AWS云中，instanceID是实例的实例id，在其他数据中心，它是实例的主机名。<br />对于XML/JSON，提供的HTTP ACCEPT类型以及内容类型必须包含application/XML或<br />application/json。

| **Operation** | **HTTP action** | **Description** |
| --- | --- | --- |
| Register new application instance | POST /eureka/v2/apps/**appID** | Input: JSON/XML payload HTTP Code: 204 on success |
| De-register application instance | DELETE /eureka/v2/apps/**appID**/**instanceID** | HTTP Code: 200 on success |
| Send application instance heartbeat | PUT /eureka/v2/apps/**appID**/**instanceID** | HTTP Code:<br />* 200 on success<br />* 404 if **instanceID** doesn’t exist |
| Query for all instances | GET /eureka/v2/apps | HTTP Code: 200 on success Output: JSON/XML |
| Query for all **appID** instances | GET /eureka/v2/apps/**appID** | HTTP Code: 200 on success Output: JSON/XML |
| Query for a specific **appID**/**instanceID** | GET /eureka/v2/apps/**appID**/**instanceID** | HTTP Code: 200 on success Output: JSON/XML |
| Query for a specific **instanceID** | GET /eureka/v2/instances/**instanceID** | HTTP Code: 200 on success Output: JSON/XML |
| Take instance out of service | PUT /eureka/v2/apps/**appID**/**instanceID**/status?value=OUT_OF_SERVICE | HTTP Code:<br />* 200 on success<br />* 500 on failure |
| Move instance back into service (remove override) | DELETE /eureka/v2/apps/**appID**/**instanceID**/status?value=UP (The value=UP is optional, it is used as a suggestion for the fallback status due to removal of the override) | HTTP Code:<br />* 200 on success<br />* 500 on failure |
| Update metadata | PUT /eureka/v2/apps/**appID**/**instanceID**/metadata?key=value | HTTP Code:<br />* 200 on success<br />* 500 on failure |
| Query for all instances under a particular **vip address** | GET /eureka/v2/vips/**vipAddress** | <br />* HTTP Code: 200 on success Output: JSON/XML<br />* 404 if the **vipAddress** does not exist. |
| Query for all instances under a particular **secure vip address** | GET /eureka/v2/svips/**svipAddress** | <br />* HTTP Code: 200 on success Output: JSON/XML<br />* 404 if the **svipAddress** does not exist. |

<a name="E4fRw"></a>
## 注册
注册时，您需要发布符合以下XSD的XML（或JSON）主体：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">
    <xsd:element name="instance">
        <xsd:complexType>
            <xsd:all>
                <!-- hostName in ec2 should be the public dns name, within ec2 public dns name will
                     always resolve to its private IP -->
                <xsd:element name="hostName" type="xsd:string" />
                <xsd:element name="app" type="xsd:string" />
                <xsd:element name="ipAddr" type="xsd:string" />
                <xsd:element name="vipAddress" type="xsd:string" />
                <xsd:element name="secureVipAddress" type="xsd:string" />
                <xsd:element name="status" type="statusType" />
                <xsd:element name="port" type="xsd:positiveInteger" minOccurs="0" />
                <xsd:element name="securePort" type="xsd:positiveInteger" />
                <xsd:element name="homePageUrl" type="xsd:string" />
                <xsd:element name="statusPageUrl" type="xsd:string" />
                <xsd:element name="healthCheckUrl" type="xsd:string" />
               <xsd:element ref="dataCenterInfo" minOccurs="1" maxOccurs="1" />
                <!-- optional -->
                <xsd:element ref="leaseInfo" minOccurs="0"/>
                <!-- optional app specific metadata -->
                <xsd:element name="metadata" type="appMetadataType" minOccurs="0" />
            </xsd:all>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="dataCenterInfo">
        <xsd:complexType>
             <xsd:all>
                 <xsd:element name="name" type="dcNameType" />
                 <!-- metadata is only required if name is Amazon -->
                 <xsd:element name="metadata" type="amazonMetdataType" minOccurs="0"/>
             </xsd:all>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="leaseInfo">
        <xsd:complexType>
            <xsd:all>
                <!-- (optional) if you want to change the length of lease - default if 90 secs -->
                <xsd:element name="evictionDurationInSecs" minOccurs="0"  type="xsd:positiveInteger"/>
            </xsd:all>
        </xsd:complexType>
    </xsd:element>

    <xsd:simpleType name="dcNameType">
        <!-- Restricting the values to a set of value using 'enumeration' -->
        <xsd:restriction base = "xsd:string">
            <xsd:enumeration value = "MyOwn"/>
            <xsd:enumeration value = "Amazon"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="statusType">
        <!-- Restricting the values to a set of value using 'enumeration' -->
        <xsd:restriction base = "xsd:string">
            <xsd:enumeration value = "UP"/>
            <xsd:enumeration value = "DOWN"/>
            <xsd:enumeration value = "STARTING"/>
            <xsd:enumeration value = "OUT_OF_SERVICE"/>
            <xsd:enumeration value = "UNKNOWN"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="amazonMetdataType">
        <!-- From <a class="jive-link-external-small" href="http://docs.amazonwebservices.com/AWSEC2/latest/DeveloperGuide/index.html?AESDG-chapter-instancedata.html" target="_blank">http://docs.amazonwebservices.com/AWSEC2/latest/DeveloperGuide/index.html?AESDG-chapter-instancedata.html</a> -->
        <xsd:all>
            <xsd:element name="ami-launch-index" type="xsd:string" />
            <xsd:element name="local-hostname" type="xsd:string" />
            <xsd:element name="availability-zone" type="xsd:string" />
            <xsd:element name="instance-id" type="xsd:string" />
            <xsd:element name="public-ipv4" type="xsd:string" />
            <xsd:element name="public-hostname" type="xsd:string" />
            <xsd:element name="ami-manifest-path" type="xsd:string" />
            <xsd:element name="local-ipv4" type="xsd:string" />
            <xsd:element name="hostname" type="xsd:string"/>       
            <xsd:element name="ami-id" type="xsd:string" />
            <xsd:element name="instance-type" type="xsd:string" />
        </xsd:all>
    </xsd:complexType>

    <xsd:complexType name="appMetadataType">
        <xsd:sequence>
            <!-- this is optional application specific name, value metadata -->
            <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="skip"/>
        </xsd:sequence>
    </xsd:complexType>

</xsd:schema>
```

<a name="eq8Ip"></a>
## 更新
示例：PUT/eureka/v2/apps/MYAPP/i-6589ef6<br />响应：<br />状态：200（成功时）<br />404（Eureka 不知道你的情况，请先注册）<br />500（故障）

<a name="YBDtY"></a>
## 取消 
如果Eureka在驱逐DurationInSecs内没有从服务节点获得检测信号，则该节点将自动取消注册<br />示例：DELETE/eureka/v2/apps/MYAPP/i-6589ef6<br />响应：<br />状态：200（成功时）<br />500（故障）

<a name="q9jDs"></a>
# 理解 Eureka 点对点通讯
Eureka 客户端尝试与同一区域中的Eureka 服务器进行对话。如果与服务器交谈时出现问题，或者服务器不在同一区域中，则客户端将故障转移到其他区域中的服务器。<br />一旦服务器开始接收流量，在服务器上执行的所有操作都会复制到服务器所知道的所有对等节点。如果某个操作由于某种原因失败，则会在下一个检测信号上协调信息，该检测信号也会在服务器之间复制。<br />当Eureka 服务器启动时，它会尝试从相邻节点获取所有实例注册表信息。如果从节点获取信息时出现问题，服务器会在放弃之前尝试所有对等节点。如果服务器能够成功获取所有实例，它会根据这些信息设置应该接收的续订阈值。如果任何时候续订率低于为该值配置的百分比（在15分钟内低于85%），服务器将停止过期实例以保护当前实例注册表信息。<br />在Netflix中，上述保护被称为自我保护模式，主要用于一组客户端和尤里卡服务器之间存在网络分区的场景中的保护。在这些场景中，服务器会尝试保护它已经拥有的信息。在大规模停机的情况下，可能会出现这样的情况，即这可能会导致客户端获得不再存在的实例。客户端必须确保它们对Eureka 服务器返回不存在或未响应的实例具有弹性。在这些情况下，最好的保护是快速超时并尝试其他服务器。<br />在服务器无法从相邻节点获取注册表信息的情况下，它会等待几分钟（5分钟），以便客户端可以注册其信息。服务器尽量不向那里的客户端提供部分信息，因为它只将流量倾斜到一组实例，并导致容量问题。<br />Eureka 服务器使用此处所述的Eureka 客户端和服务器之间使用的相同机制相互通信。<br />同样值得注意的是，如果需要，可以在服务器上调整几种配置，包括服务器之间的通信。

<a name="pDcEh"></a>
## 点对点的网络中断期间会发生什么？
在对等方之间发生网络中断的情况下，可能会发生以下情况：

- 对等端之间的心跳复制可能会失败，服务器检测到这种情况并进入保护当前状态的自我保护模式。
- 注册可能发生在独立服务器中，一些客户端可能会反映新的注册，而其他客户端可能不会。
- 在网络连接恢复到稳定状态后，情况会自动更正。当对等端能够良好地通信时，注册信息会自动传输到没有它们的服务器。

底线是，在网络中断期间，服务器尽可能具有弹性，但在此期间，客户端可能对服务器有不同的看法。

<a name="l2Nzo"></a>
# 
<a name="QU2w2"></a>
## 
